[{"categories":null,"content":"在 Go 中 panic 会导致程序被中止，但是在退出前，会先处理完当前协程上已经 defer 的任务，执行完成后再退出。效果类似于 java 语言的 try...catch。defer 的任务执行完成之后，panic 还会继续被抛出，导致程序非正常结束。 Go 语言还提供了 recover 函数，可以避免因为 panic 发生而导致整个程序终止，recover 函数只在 defer 中生效。 // hello.go func test_recover() { defer func() { fmt.Println(\"defer func\") if err := recover(); err != nil { fmt.Println(\"recover success\") } }() arr := []int{1, 2, 3} fmt.Println(arr[4]) fmt.Println(\"after panic\") } func main() { test_recover() fmt.Println(\"after recover\") } 我们要给gee做一个内置的recovery机制，使得用户调用的函数出现了错误，也能出现Internal Server Error，而不是直接退出进程。 实际上是实现一个recovery中间件： package gee import ( \"fmt\" \"log\" \"net/http\" \"runtime\" \"strings\" ) // print stack trace for debug func trace(message string) string { var pcs [32]uintptr n := runtime.Callers(3, pcs[:]) // skip first 3 caller var str strings.Builder str.WriteString(message + \"\\nTraceback:\") for _, pc := range pcs[:n] { fn := runtime.FuncForPC(pc) file, line := fn.FileLine(pc) str.WriteString(fmt.Sprintf(\"\\n\\t%s:%d\", file, line)) } return str.String() } func Recovery() HandlerFunc { return func(c *Context) { defer func() { if err := recover(); err != nil { message := fmt.Sprintf(\"%s\", err) log.Printf(\"%s\\n\\n\", trace(message)) c.Fail(http.StatusInternalServerError, \"Internal Server Error\") } }() c.Next() } } gee默认使用Logger和Recovery中间件，这样就实现了恢复功能。 ","date":"2023-07-03","objectID":"/%E7%94%A8golang%E5%86%99geeday7/:0:0","tags":["Go","CS"],"title":"用golang写gee(day7)","uri":"/%E7%94%A8golang%E5%86%99geeday7/"},{"categories":null,"content":"利用http包的http.FileServer，结合动态路由来实现Static方法，随意访问任意路径下的文件。 // create static handler func (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc { absolutePath := path.Join(group.prefix, relativePath) fileServer := http.StripPrefix(absolutePath, http.FileServer(fs)) return func(c *Context) { file := c.Param(\"filepath\") // Check if file exists and/or if we have permission to access it if _, err := fs.Open(file); err != nil { c.Status(http.StatusNotFound) return } fileServer.ServeHTTP(c.Writer, c.Req) } } // serve static files func (group *RouterGroup) Static(relativePath string, root string) { handler := group.createStaticHandler(relativePath, http.Dir(root)) urlPattern := path.Join(relativePath, \"/*filepath\") // Register GET handlers group.GET(urlPattern, handler) } 代码非常浅显易懂。 模板的知识不太了解，暂时不做。 ","date":"2023-06-30","objectID":"/%E7%94%A8golang%E5%86%99geeday6/:0:0","tags":["Go","CS"],"title":"用golang写gee(day6)","uri":"/%E7%94%A8golang%E5%86%99geeday6/"},{"categories":null,"content":"项目地址：https://geektutu.com/post/gee-day5.html 今天的目的是在Group中嵌入中间件。中间件的使用方式为： func (r *RouterGroup) Use(middlewares ...HandlerFunc) 对于两个中间件A,B，嵌套后的调用顺序为：part1 -\u003e part3 -\u003e Handler -\u003e part 4 -\u003e part2 func A(c *Context) { part1 c.Next() part2 } func B(c *Context) { part3 c.Next() part4 } 实际上，访问资源时，middleware从Group传递到Context，而Context被handle时，加入注册于该Group的handler（使用method+pattern注册的），再调用c.Next()来开始运行这一系列函数表（middlewares+handler）。 func (r *router) handle(c *Context) { n, params := r.getRoute(c.Method, c.Path) if n != nil { c.Params = params key := c.Method + \"-\" + n.pattern c.handlers = append(c.handlers, r.handlers[key]) } else { c.handlers = append(c.handlers, func(c *Context) { c.String(http.StatusNotFound, \"404 NOT FOUND\") }) } c.Next() } func (c *Context) Next() { c.index++ s := len(c.handlers) for ; c.index \u003c s; c.index++ { c.handlers[c.index](c) } } 在运行某个函数时，随时可以使用c.Next()来跳出函数，执行index指向的下个函数。（这里能产生很多种调用行为顺序，比如可以一个主函数+多个子函数） ","date":"2023-06-23","objectID":"/%E7%94%A8golang%E5%86%99geeday5/:0:0","tags":["Go","CS"],"title":"用golang写gee(day5)","uri":"/%E7%94%A8golang%E5%86%99geeday5/"},{"categories":null,"content":"项目地址：https://geektutu.com/post/gee-day4.html ","date":"2023-06-20","objectID":"/%E7%94%A8golang%E5%86%99geeday4/:0:0","tags":["Go","CS"],"title":"用golang写gee(day4)","uri":"/%E7%94%A8golang%E5%86%99geeday4/"},{"categories":null,"content":"目标 这次要完成http的分组功能，简而言之，就是对于一些具有共同前缀的资源，我们可以通过哦Group（）来一起注册，且可以嵌入中间件，使得这些资源都有相同的特性。最终使用效果如下： func main() { r := gee.New() r.GET(\"/index\", func(c *gee.Context) { c.HTML(http.StatusOK, \"\u003ch1\u003eIndex Page\u003c/h1\u003e\") }) v1 := r.Group(\"/v1\") { v1.GET(\"/\", func(c *gee.Context) { c.HTML(http.StatusOK, \"\u003ch1\u003eHello Gee\u003c/h1\u003e\") }) v1.GET(\"/hello\", func(c *gee.Context) { // expect /hello?name=geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Query(\"name\"), c.Path) }) } v2 := r.Group(\"/v2\") { v2.GET(\"/hello/:name\", func(c *gee.Context) { // expect /hello/geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Param(\"name\"), c.Path) }) v2.POST(\"/login\", func(c *gee.Context) { c.JSON(http.StatusOK, gee.H{ \"username\": c.PostForm(\"username\"), \"password\": c.PostForm(\"password\"), }) }) } r.Run(\":9999\") } 可以看得出来，这样实现会比较简洁漂亮。也可以使用嵌套和中间件。 ","date":"2023-06-20","objectID":"/%E7%94%A8golang%E5%86%99geeday4/:0:1","tags":["Go","CS"],"title":"用golang写gee(day4)","uri":"/%E7%94%A8golang%E5%86%99geeday4/"},{"categories":null,"content":"实现 定义RouterGroup类型，Engine本身就是一个RouterGroup，而所有的RouterGroup都指向一个Engine。 RouterGroup struct { prefix string middlewares []HandlerFunc // support middleware parent *RouterGroup // support nesting engine *Engine // all groups share a Engine instance } Engine struct { *RouterGroup router *router groups []*RouterGroup // store all groups } 留意Engine在初始化时，Groups只包含它自身的RouterGroup。将原来为Engine实现的GET等方法，改为为RouterGroup的，此时Engine也可以隐性调用这些成员函数。这样就可以偷龙转凤一般，实现这种效果： v1 := r.Group(\"/v1\") { v1.GET(\"/\", func(c *gee.Context) { c.HTML(http.StatusOK, \"\u003ch1\u003eHello Gee\u003c/h1\u003e\") }) v1.GET(\"/hello\", func(c *gee.Context) { // expect /hello?name=geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Query(\"name\"), c.Path) }) } 说白了，现在就是加了个前缀功能而已。Grouping真正的威力要在中间件中体现出来吧？ ","date":"2023-06-20","objectID":"/%E7%94%A8golang%E5%86%99geeday4/:0:2","tags":["Go","CS"],"title":"用golang写gee(day4)","uri":"/%E7%94%A8golang%E5%86%99geeday4/"},{"categories":null,"content":"项目地址：https://geektutu.com/post/gee-day3.html ","date":"2023-06-19","objectID":"/%E7%94%A8golang%E5%86%99geeday3/:0:0","tags":["Go","CS"],"title":"用golang写gee(day3)","uri":"/%E7%94%A8golang%E5%86%99geeday3/"},{"categories":null,"content":"目标 day3的任务是，实现http的动态路由，即访问路径带有:name的资源时，可以顺利匹配；访问路径带有*的资源时，直接匹配后面所有资源。 例如/p/go/doc匹配到/p/:lang/doc，解析结果为：{lang: \"go\"}，/static/css/geektutu.css匹配到/static/*filepath，解析结果为{filepath: \"css/geektutu.css\"}。 ","date":"2023-06-19","objectID":"/%E7%94%A8golang%E5%86%99geeday3/:0:1","tags":["Go","CS"],"title":"用golang写gee(day3)","uri":"/%E7%94%A8golang%E5%86%99geeday3/"},{"categories":null,"content":"实现 主要是实现一个简单的前缀树来完成。 type node struct { pattern string // 待匹配路由 /p/:lang part string // :lang children []*node isWild bool //是否精确匹配,part 含有:或* } 这里pattern是该资源的实际路径，而part是将该资源路径切开后的切片，如info和 ：name。实现简单的insert和search操作后，嵌入到router里面。 func (r *router) addRoute(method string, pattern string, handler HandlerFunc) { parts := parsePattern(pattern) _, ok := r.roots[method] if !ok { r.roots[method] = \u0026node{} } r.roots[method].insert(pattern, parts, 0) //插入到trieTree key := method + \"-\" + pattern r.handlers[key] = handler } func (r *router) getRoute(method string, path string) (*node, map[string]string) { searchParts := parsePattern(path) params := make(map[string]string) root, ok := r.roots[method] if !ok { return nil, nil } n := root.search(searchParts, 0) //在trieTree中搜索 if n != nil { parts := parsePattern(n.pattern) for index, part := range parts { if part[0] == ':' { params[part[1:]] = searchParts[index] } if part[0] == '*' \u0026\u0026 len(part) \u003e 1 { params[part[1:]] = strings.Join(searchParts[index:], \"/\") break } } return n, params } return nil, nil } func (r *router) handle(c *Context) { n, params := r.getRoute(c.Method, c.Path) if n != nil { c.Params = params //更新动态路由参数 key := c.Method + \"-\" + n.pattern r.handlers[key](c) } else { c.String(http.StatusNotFound, \"404 NOT FOUND\") } } 只有实际可以访问的节点的pattern设置为实际访问路径，其余父节点为空，注意这个判断即可。 func (n *node) search(parts []string, height int) *node { if len(parts) == height || strings.HasPrefix(n.part, \"*\") { if n.pattern == \"\" { return nil } return n } ","date":"2023-06-19","objectID":"/%E7%94%A8golang%E5%86%99geeday3/:0:2","tags":["Go","CS"],"title":"用golang写gee(day3)","uri":"/%E7%94%A8golang%E5%86%99geeday3/"},{"categories":null,"content":"单元测试 func newTestRouter() *router { r := newRouter() r.addRoute(\"GET\", \"/\", nil) r.addRoute(\"GET\", \"/hello/:name\", nil) r.addRoute(\"GET\", \"/hello/b/c\", nil) r.addRoute(\"GET\", \"/hi/:name\", nil) r.addRoute(\"GET\", \"/assets/*filepath\", nil) return } func TestParsePattern(t *testing.T) { ok := reflect.DeepEqual(parsePattern(\"/p/:name\"), []string{\"p\", \":name\"}) ok = ok \u0026\u0026 reflect.DeepEqual(parsePattern(\"/p/*\"), []string{\"p\", \"*\"}) ok = ok \u0026\u0026 reflect.DeepEqual(parsePattern(\"/p/*name/*\"), []string{\"p\", \"*name\"}) if !ok { t.Fatal(\"test parsePattern failed\") } } func TestGetRoute(t *testing.T) { r := newTestRouter() n, ps := r.getRoute(\"GET\", \"/hello/geektutu\") if n == nil { t.Fatal(\"nil shouldn't be returned\") } if n.pattern != \"/hello/:name\" { t.Fatal(\"should match /hello/:name\") } if ps[\"name\"] != \"geektutu\" { t.Fatal(\"name should be equal to 'geektutu'\") } fmt.Printf(\"matched path: %s, params['name']: %s\\n\", n.pattern, ps[\"name\"]) } ","date":"2023-06-19","objectID":"/%E7%94%A8golang%E5%86%99geeday3/:0:3","tags":["Go","CS"],"title":"用golang写gee(day3)","uri":"/%E7%94%A8golang%E5%86%99geeday3/"},{"categories":null,"content":"SplayTree伸展树用于毕业设计之中，它本身是一种常见的数据结构算法。 输入法候选框的基本原理就是Spaly Tree，每次要访问一个节点，都会将该节点旋到root，同时保持排序树的性质不变。长久下来，经常访问的数据就会更靠近root，就会更快的被访问，像CACHE一样，频繁的数据最快。 Splay Tree 的基本操作都基于伸展 (Splay) 操作,通过一系列的树旋转(Zig 和 Zag 操作),在把指定顶点移动到根顶点的同时,通过调整把树的结构平衡化。每次访问完一个顶点,就将该顶点进行 Splay 操作。越是经常被访问的顶点,其深度就越小,越容 易被寻找到,达到了缓存加速的效果。Splay Tree 的插入顶点过程也类似于一般的二叉查找树。 为了避免旋转的过程中,树退化成链的情况发生,Splay 采用了双旋的方法。考虑 旋转顶点 v 的父顶点和祖父顶点的情况,保证在旋转后不会产生退化成链的情况,尽可能地在把顶点 v 上浮的同时,平衡左右子树。 // C++ code for the above approach: #include \u003cbits/stdc++.h\u003e using namespace std; struct node { int key; node *left, *right; }; node* newNode(int key) { node* temp = new node; temp-\u003ekey = key; temp-\u003eleft = temp-\u003eright = NULL; return temp; } node* rightRotate(node* x) { node* y = x-\u003eleft; x-\u003eleft = y-\u003eright; y-\u003eright = x; return y; } node* leftRotate(node* x) { node* y = x-\u003eright; x-\u003eright = y-\u003eleft; y-\u003eleft = x; return y; } node* splay(node* root, int key) { if (root == NULL || root-\u003ekey == key) return root; if (root-\u003ekey \u003e key) { if (root-\u003eleft == NULL) return root; if (root-\u003eleft-\u003ekey \u003e key) { root-\u003eleft-\u003eleft = splay(root-\u003eleft-\u003eleft, key); root = rightRotate(root); } else if (root-\u003eleft-\u003ekey \u003c key) { root-\u003eleft-\u003eright = splay(root-\u003eleft-\u003eright, key); if (root-\u003eleft-\u003eright != NULL) root-\u003eleft = leftRotate(root-\u003eleft); } return (root-\u003eleft == NULL) ? root : rightRotate(root); } else { if (root-\u003eright == NULL) return root; if (root-\u003eright-\u003ekey \u003e key) { root-\u003eright-\u003eleft = splay(root-\u003eright-\u003eleft, key); if (root-\u003eright-\u003eleft != NULL) root-\u003eright = rightRotate(root-\u003eright); } else if (root-\u003eright-\u003ekey \u003c key) { root-\u003eright-\u003eright = splay(root-\u003eright-\u003eright, key); root = leftRotate(root); } return (root-\u003eright == NULL) ? root : leftRotate(root); } } node* insert(node* root, int key) { if (root == NULL) return newNode(key); root = splay(root, key); if (root-\u003ekey == key) return root; node* temp = newNode(key); if (root-\u003ekey \u003e key) { temp-\u003eright = root; temp-\u003eleft = root-\u003eleft; root-\u003eleft = NULL; } else { temp-\u003eleft = root; temp-\u003eright = root-\u003eright; root-\u003eright = NULL; } return temp; } // Drivers code int main() { node* root = NULL; root = insert(root, 100); root = insert(root, 50); root = insert(root, 200); root = insert(root, 40); root = insert(root, 60); cout \u003c\u003c \"Preorder traversal of the modified Splay \" \"tree: \\n\"; return 0; } ","date":"2023-06-18","objectID":"/splay%E4%BC%B8%E5%B1%95%E6%A0%91/:0:0","tags":["毕业设计","CS","数据结构"],"title":"SPLAY伸展树","uri":"/splay%E4%BC%B8%E5%B1%95%E6%A0%91/"},{"categories":null,"content":"项目地址：https://geektutu.com/post/gee-day2.html ","date":"2023-06-18","objectID":"/%E7%94%A8golang%E5%86%99geeday2/:0:0","tags":["Go","CS"],"title":"用golang写gee(day2)","uri":"/%E7%94%A8golang%E5%86%99geeday2/"},{"categories":null,"content":"目标 今天的目的是，进一步把engine抽象成router，且可以使用JSON等高度封装的函数，如： func handler1(c *gee.Context) { m := map[string]interface{}{ \"name\": \"hongwei7\", \"age\": 25, } c.JSON(http.StatusOK, m) } ","date":"2023-06-18","objectID":"/%E7%94%A8golang%E5%86%99geeday2/:0:1","tags":["Go","CS"],"title":"用golang写gee(day2)","uri":"/%E7%94%A8golang%E5%86%99geeday2/"},{"categories":null,"content":"原理 这样的调用无疑是更加方便，更加适合网络开发的。实现的原理，实际上就是将ResponseWriter和Request打包成gee.Context，再实现相应的函数。（不过要注意这里的Context和go里面的Context不是同一个概念） type Context struct { Writer http.ResponseWriter Req *http.Request Path string Method string StatusCode int } func (c *Context) JSON(code int, obj interface{}) { c.SetHeader(\"Content-Type\", \"application/json\") c.Status(code) encoder := json.NewEncoder(c.Writer) if err := encoder.Encode(obj); err != nil { http.Error(c.Writer, err.Error(), 500) } } 这样的简单封装，省略了各种状态码和返回类型header的填写。最后可以这样使用我们的gee了： func helloHandler(c *gee.Context) { c.String(http.StatusOK, \"hello world\") } func handler1(c *gee.Context) { m := map[string]interface{}{ \"name\": \"hongwei7\", \"age\": 25, } c.JSON(http.StatusOK, m) } func main() { gee := gee.New() gee.GET(\"/hello\", helloHandler) gee.GET(\"/\", handler1) gee.Run() } 这就是day2的内容。 ","date":"2023-06-18","objectID":"/%E7%94%A8golang%E5%86%99geeday2/:0:2","tags":["Go","CS"],"title":"用golang写gee(day2)","uri":"/%E7%94%A8golang%E5%86%99geeday2/"},{"categories":null,"content":"项目地址：https://geektutu.com/post/gee-day1.html ","date":"2023-06-15","objectID":"/%E7%94%A8golang%E5%86%99geeday1/:0:0","tags":["Go","CS"],"title":"用golang写gee(day1)","uri":"/%E7%94%A8golang%E5%86%99geeday1/"},{"categories":null,"content":"实现 第一天主要介绍net/http模块的用法，实现了里面的Handler interface，从而接管了整个http库的行为。 // net/http主要进入函数 func ListenAndServe(addr string, handler Handler) error { server := \u0026Server{Addr: addr, Handler: handler} return server.ListenAndServe() } // Handler接口如下 type Handler interface { ServeHTTP(ResponseWriter, *Request) } 所以自己完全可以封装一个Handler。另外简单实现了一个string map router，记录了所有的处理函数，并实现了添加和调用这些处理函数的接口。核心封装函数如下： type HandlerFunc func(http.ResponseWriter, *http.Request) type Engine struct { router map[string]HandlerFunc } func New() *Engine { return \u0026Engine{make(map[string]HandlerFunc)} } func (engine *Engine) addRouter(method string, pattern string, handler HandlerFunc) { key := method + \"-\" + pattern engine.router[key] = handler } func (engine *Engine) GET(pattern string, handler HandlerFunc) { engine.addRouter(\"GET\", pattern, handler) } func (engine *Engine) POST(pattern string, handler HandlerFunc) { engine.addRouter(\"POST\", pattern, handler) } func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { key := req.Method + \"-\" + req.URL.Path if handler, ok := engine.router[key]; ok { handler(w, req) } else { fmt.Fprintf(w, \"404 NOT FOUND: %q\", req.URL.Path) } } func (engine *Engine) Run() { http.ListenAndServe(\":9999\", engine) } ","date":"2023-06-15","objectID":"/%E7%94%A8golang%E5%86%99geeday1/:0:1","tags":["Go","CS"],"title":"用golang写gee(day1)","uri":"/%E7%94%A8golang%E5%86%99geeday1/"},{"categories":null,"content":"总结 第一天的内容还是较为简单的，主要是简单封装了一下net/http库。还有就是感觉用go写出来的代码都长得差不多，像func New()这种写法都是固定的。 ","date":"2023-06-15","objectID":"/%E7%94%A8golang%E5%86%99geeday1/:0:2","tags":["Go","CS"],"title":"用golang写gee(day1)","uri":"/%E7%94%A8golang%E5%86%99geeday1/"},{"categories":null,"content":"理解平摊分析 [MIT算法导论第13集] 平摊分析，表的扩增，势能方法_哔哩哔哩_bilibili ","date":"2022-04-12","objectID":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/:0:0","tags":["算法"],"title":"理解平摊分析","uri":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/"},{"categories":null,"content":"哈希表的均摊分析 Hash Table 在足够长时，搜索时间会很短。 提出dynamic tables：当 Hash Table 元素过多的时候，grow it。这意味着要copy所有的旧元素到新空间之中。 此时插入的最高代价为O(n)，但并不是每次都是O(n)。 因此时间复杂度为： $$ \\sum_{i=1}^n c_i = n+\\sum_{j=0}^{[\\log(n-1)]}2^j\\leq 3n $$ 均摊则为： $$ \\frac1n\\sum_{i=1}^n c_i=O(1) $$ ⛱️ 对于很多数据结构而言，只需要证明某次复杂的操作复杂度小于O(n)。 ","date":"2022-04-12","objectID":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/:1:0","tags":["算法"],"title":"理解平摊分析","uri":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/"},{"categories":null,"content":"三种均摊分析方法 聚集方法（就是直接算出n步的总复杂度）。 记账法。 势能法。 后两种方法能更精确地表达每个操作的平摊复杂度是多少。 ","date":"2022-04-12","objectID":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/:2:0","tags":["算法"],"title":"理解平摊分析","uri":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/"},{"categories":null,"content":"记账法 对每个操作$c_i$进行收费（虚构的平摊代价），如果支付的费用不够，则余额来支付。且不能向未来借款。 $$ \\sum_{i=1}^n c_i\\leq\\sum_{i=1}^n \\hat{c_i} $$ 对于动态hash table，假设每个操作有3元： 直接插入时： 插入支出1元。 存储2元。 需要翻倍时： 移动旧元素从银行取出n元。 插入新元素支出1元。 储存2元。 如此过程，可以持续（显然），说明每个操作平摊复杂度上界为3元。 ","date":"2022-04-12","objectID":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/:3:0","tags":["算法"],"title":"理解平摊分析","uri":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/"},{"categories":null,"content":"势能方法 实际上银行账户就是我们要分析的势能。 从数据结构$D_0$开始，$i$操作将$D_{i-1}$转化为$D_i$。定义$\\Phi$为数据结构到实数的映射，使得$\\Phi(D_0)=0$，且$\\Phi(D_i)\u003e=0$。 定义平摊代价为$\\hat{c_i}$， $$ \\hat{c_i}=c_i+\\Phi(D_i)-\\Phi(D_{i-1})=c_i+\\Delta\\Phi_i $$ 若$\\Delta\\Phi_i\\geq0$，那么说明操作$i$可以存储一些功到银行。 否则，则说明操作$i$需要取出一些功。 因此，只要找到适合的势函数（任意符合条件$\\Phi(D_0)=0$，且$\\Phi(D_i)\u003e=0$的函数），那么就可以得到均摊复杂度的其中一个上界。 $$ \\begin{aligned}\\frac1n\\sum_{i=1}^n\\hat{c_i}\u0026=\\frac1n\\sum_{i=1}^n(c_i+\\Phi(D_i)-\\Phi(D_{i-1}))\\ \u0026=\\frac1n\\sum_{i=1}^nc_i+\\frac1n\\Phi(D_i) \\ \u0026 \\geq\\frac1n\\sum_{i=1}^nc_i\\end{aligned} $$ 实际上势能方法，只是用代数来更精确地靠近上界。但是原理跟记账法其实是相同的。 ","date":"2022-04-12","objectID":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/:4:0","tags":["算法"],"title":"理解平摊分析","uri":"/%E7%90%86%E8%A7%A3%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-7a26c/"},{"categories":null,"content":"Golang笔记 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:0:0","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"基础 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:1:0","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"基本语法 通过官网 A Tour Of Go 学习 golang 基本语法。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:1:1","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"struct golang 通过 struct 来实现其他语言中的 class，但是在 golang 中没有继承的概念。 golang 中使用组合函数的方法来定义结构体函数： func (person Profile) FmtProfile() { fmt.Printf(\"名字：%s\\n\", person.name) fmt.Printf(\"年龄：%d\\n\", person.age) fmt.Printf(\"性别：%s\\n\", person.gender) } 当需要改变对象内容或者结构体过大需要性能提升时，使用指针作为方法接收者。 func (person *Profile) FmtProfile() { fmt.Printf(\"名字：%s\\n\", person.name) fmt.Printf(\"年龄：%d\\n\", person.age) fmt.Printf(\"性别：%s\\n\", person.gender) } golang 使用组合的方法来实现继承。 golang 使用接口（Interface）来实现多态。 type Goodinterface { settleAccount() int orderInfo() string } type Phonestruct { name string quantity int price int } func (phone Phone) settleAccount() int { return phone.quantity * phone.price } func (phone Phone) orderInfo() string{ return \"您要购买\" + strconv.Itoa(phone.quantity)+ \"个\" + phone.name + \"计：\" + strconv.Itoa(phone.settleAccount()) + \"元\" } type FreeGiftstruct { name string quantity int price int } func (gift FreeGift) settleAccount() int { return 0 } func (gift FreeGift) orderInfo() string{ return \"您要购买\" + strconv.Itoa(gift.quantity)+ \"个\" + gift.name + \"计：\" + strconv.Itoa(gift.settleAccount()) + \"元\" } func calculateAllPrice(goods []Good) int { var allPrice int for _,good :=range goods{ fmt.Println(good.orderInfo()) allPrice += good.settleAccount() } return allPrice } golang 利用反射机制来实现 Tag。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:1:2","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"反射 获取一个对象的类型，属性及方法，这个过程其实就是 反射。 reflect包最核心的两个函数为： reflect.TypeOf(i) reflect.ValueOf(i) 两个函数分别返回 reflect.Type 和 reflect.Value 类型。 优点： 可以在一定程度上避免硬编码，提供灵活性和通用性。 可以作为一个第一类对象发现并修改源代码的结构（如代码块、类、方法、协议等）。 可以在运行时像对待源代码语句一样动态解析字符串中可执行的代码（类似JavaScript的eval()函数），进而可将跟class或function匹配的字符串转换成class或function的调用或引用。 可以创建一个新的语言字节码解释器来给编程结构一个新的意义或用途。 缺点： 此技术的学习成本高。面向反射的编程需要较多的高级知识，包括框架、关系映射和对象交互，以实现更通用的代码执行。 同样因为反射的概念和语法都比较抽象，过多地滥用反射技术会使得代码难以被其他人读懂，不利于合作与交流。 由于将部分信息检查工作从编译期推迟到了运行期，此举在提高了代码灵活性的同时，牺牲了一点点运行效率。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:1:3","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"类型断言 通过类型断言可以判断某个对象不是nil，且为某个类型。 t := i.(T) // 会触发panic t, ok:= i.(T) // 不会触发panic 甚至可以通过 type switch 来实现不同的行为： func findType(i interface{}) { switch x := i.(type) { case int: fmt.Println(x, \"is int\") case string: fmt.Println(x, \"is string\") case nil: fmt.Println(x, \"is nil\") default: fmt.Println(x, \"not type matched\") } } ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:1:4","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"goroutine 和 channel golang 原生支持 gotoutine 协程。 channel 的容量不同，会有不同的用法。 当容量为0时，说明信道中不能存放数据，在发送数据时，必须要求立马有人接收，否则会报错。此时的信道称之为无缓冲信道。 当容量为1时，说明信道只能缓存一个数据，若信道中已有一个数据，此时再往里发送数据，会造成程序阻塞。 利用这点可以利用信道来做锁。 当容量大于1时，信道中可以存放多个数据，可以用于多个协程之间的通信管道，共享资源。 注意 channel 传输的是否为引用： 值类型 ：String，Array，Int，Struct，Float，Bool 引用类型：Slice，Map 若传入的是值类型，那么传输的是值；若传入的是引用类型，那么传输的是引用（指针）。 从已关闭的 channel 读取消息永远不会阻塞，并且会返回一个为 false 的值，用以判断该 channel 是否已关闭（x,ok := \u003c- ch） 万能的 channel 使用公式： 4.10 学习 Go 协程：万能的通道模型(公式) - Go编程时光 1.0.0 documentation ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:1:5","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"Context 实际上 Context 是一个接口： type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key interface{})interface{} } Deadline 返回截止时间。 Done 返回只读的通道，当返回一个 struct{} 时，代表 parent context 发起了取消。 Err 返回错误原因。 Value 返回被绑定的值。 有四个常用的函数： func WithCancel(parent Context) (ctx Context, cancel CancelFunc) func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) func WithValue(parent Context, key, valinterface{}) Context 通常 Context 都是做为函数的第一个参数进行传递（规范性做法），并且变量名建议统一叫 ctx Context 是线程安全的，可以放心地在多个 goroutine 中使用。 当你把 Context 传递给多个 goroutine 使用时，只要执行一次 cancel 操作，所有的 goroutine 就可以收到 取消的信号 不要把原本可以由函数参数来传递的变量，交给 Context 的 Value 来传递。 当一个函数需要接收一个 Context 时，但是此时你还不知道要传递什么 Context 时，可以先用 context.TODO 来代替，而不要选择传递一个 nil。 当一个 Context 被 cancel 时，继承自该 Context 的所有 子 Context 都会被 cancel。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:1:6","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"进阶 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:0","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"goroutine 的生成调度 golang 的 goroutine 使用的调度方式是 MPG 模型。 一个M对应一个系统内核线程，一个P对应一个上下文，一个上下文连接一个或多个 G goroutine。蓝色的 G 代表运行中。 当一个 Goroutine 创建被创建时，Goroutine 对象被压入 Processor 的本地队列或者 Go 运行时 全局 Goroutine 队列。 Processor 唤醒一个 Machine，如果 Machine 的 waiting 队列没有等待被 唤醒的 Machine， 则创建一个（只要不超过 Machine 的最大值，10000），Processor 获取到 Machine 后，与 此 Machine 绑定，并执行此 Goroutine。 Machine 执行过程中，随时会发生上下文切换。当发生上下文切换时，需要对执行现场进行 保护，以便下次被调度执行时进行现场恢复。Go 调度器中 Machine 的栈保存在 Goroutine 对 象上，只需要将 Machine 所需要的寄存器(堆栈指针、程序计数器等)保存到 Goroutine 对象上 即可。 如果此时 Goroutine 任务还没有执行完，Machine 可以将 Goroutine 重新压入 Processor 的队 列，等待下一次被调度执行。 如果执行过程遇到阻塞并阻塞超时，Machine 会与 Processor 分离，并等待阻塞结束。此时 Processor 可以继续唤醒 Machine 执行其它的 Goroutine，当阻塞结束时，Machine 会尝试” 偷取”一个 Processor，如果失败，这个 Goroutine 会被加入到全局队列中，然后 Machine 将 自己转入 Waiting 队列，等待被再次唤醒。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:1","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"defer defer 为延后执行语句，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行。通常作为资源的释放。 func fileSize(filename string) int64 { f, err := os.Open(filename) if err != nil { return 0 } // 延迟调用Close, 此时Close不会被调用 defer f.Close() info, err := f.Stat() if err != nil { // defer机制触发, 调用Close关闭文件 return 0 } size := info.Size() // defer机制触发, 调用Close关闭文件 return size } ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:2","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"recover 和 panic 有 panic 没 recover，程序宕机。 有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。 import \"fmt\" func set_data(x int) { defer func() { // recover() 可以将捕获到的panic信息打印 if err := recover(); err != nil { fmt.Println(err) } }() // 故意制造数组越界，触发 panic var arr [10]int arr[x] = 88 } func main() { set_data(20) // 如果能执行到这句，说明panic被捕获了 // 后续的程序能继续运行 fmt.Println(\"everything is ok\") } ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:3","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"array 和 slice slice可以被认为动态数组，在内存中也是连续分配的。他可以动态的调整长度，可以通过内置的方法append来自动的增长slice长度;也可以通过再次切片来减少slice的长度。 用append给这个slice添加新值，返回一个新的slice，如果容量不够时，go会自动增加容易量，小于一1000个长度时成倍的增长，大于1000个长度时会以1.25或者25%的位数增长。 array 在函数中参数传递的是值，slice 传递的是指针。 新创建的slice2和slice1底层是同一个数组，所以修改任何一个，两个slice共同的指向元素，会导致同时修改的问题. // 创建一个容量和长度均为6的slice slice1 := []int{5, 23, 10, 2, 61, 33} // 对slices1进行切片，长度为2容量为4 slice2 := slice1[1:3] fmt.Println(\"cap\", cap(slice2)) fmt.Println(\"slice2\", slice2) //修改一个共同指向的元素 //两个slice的值都会修改 slice2[0] = 11111 fmt.Println(\"slice1\", slice1) fmt.Println(\"slice2\", slice2) 创建新的slice可以设置其cap，但是不能超过原底层数组的长度。此时对新的slice进行append，仍然会影响原来的slice。 // 创建一个容量和长度均为6的slice slice1 := []int{5, 23, 10, 2, 61, 33} // 对slices1进行切片，长度为2容量为3 slice2 := slice1[1:3:4] fmt.Println(\"cap\", cap(slice2)) fmt.Println(\"slice2\", slice2) //修改一个共同指向的元素 //两个slice的值都会修改 slice2[0] = 11111 fmt.Println(\"slice1\", slice1) fmt.Println(\"slice2\", slice2) // 增加一个元素 slice2 = append(slice2, 55555) fmt.Println(slice1) fmt.Println(slice2) 如果在创建新的slice时我们把他的长度和容量的值设置为样的值，那么在append新元素时，底层会创建一个新的array并把之前的值复制过去。这样就不会影响之前共同的底层array了。 // 创建一个容量和长度均为6的slice slice1 := []int{5, 23, 10, 2, 61, 33} // 对slices1进行切片，长度为2容量为3 slice2 := slice1[1:3:3] fmt.Println(\"cap\", cap(slice2)) fmt.Println(\"slice2\", slice2) //修改一个共同指向的元素 //两个slice的值都会修改 slice2[0] = 11111 fmt.Println(\"slice1\", slice1) fmt.Println(\"slice2\", slice2) // 增加一个元素 slice2 = append(slice2, 55555) fmt.Println(\"slice1: \", slice1) fmt.Println(\"slice2: \", slice2) ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:4","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"闭包外部变量的生命周期 若引用的是全局变量或者没有引用变量，则变量的生命周期为全局变量的生命周期。 若引用的是局部变量，每次调用完闭包，不会释放变量。这种场景下，是真正的闭包（函数+引用环境），并且以一个struct{FuncAddr, LocalAddr3, LocalAddr2, LocalAddr1}结构存储该闭包到堆中，等到调用闭包时，会把该结构地址提前放置一个寄存器，闭包内部通过该寄存器访问引用环境的变量。 当不再有变量引用闭包时，该闭包会被GC回收，局部变量也一样。 func fib3(x int) func() int { a, b := 0, 1 return func() int { a, b = b, a+b x++ return a+x } } 所有引用局部变量，Golang在生成汇编是帮我们在堆上创建该变量的一个拷贝，并把该变量地址和函数闭包组成一个结构体，并把该结构体传出来作为返回值。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:5","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"垃圾回收 Go 语言垃圾收集器的实现原理 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:6","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"标记清除法 内存空间中包含多个对象，从根对象开始依次遍历子对象（标记过程），没有被遍历到的对象便为垃圾（随后在清除阶段清理）。 清理后的对象空间用链表结构串联起来（可以添加cookie或者标志位来实现）。 问题：用户程序在标记清除的过程中不能执行（长时间的 STW ）。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:7","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"三色抽象 三色标记法可以缩短STW时间。 白色：潜在的垃圾，可能被回收。 黑色：活跃的对象，包括不存在任何外部指针引用，以及从根对象不可达的。 灰色：活跃的对象，存在外部指针引用或从根对象可达。 工作过程： 根对象被标记成灰色。收集器只会从灰色对象集合中扫描，灰色集合不存在对象时，标记阶段结束。 从灰色集合中选择一个灰色对象，标记成黑色。 黑色对象指向的所有对象都标记成灰色。（这样该对象不会被回收） 重复以上两个步骤不存在灰色。 当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾。 但是在运行过程中，会发生指针修改的问题，因此三色标记算法还是不可以并发或增量地运行。 因此，便有了屏障技术。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:8","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"屏障技术 内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。 要想并发或增量地运行三色标记算法，要达成两种三色不变性其中的一种： 强三色不变性：黑色对象不会指向白色对象。 弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径。（垃圾收集器无法从某个灰色对象出发，经过几个连续的白色对象访问白色的 C 和 D 两个对象） 编程语言往往都会采用写屏障保证三色不变性。Go 语言中使用的两种写屏障技术，分别是 Dijkstra 提出的插入写屏障和 Yuasa 提出的删除写屏障。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:9","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"插入写屏障 写屏障相当于一个钩子方法。 在执行 *slot = ptr 时，若 ptr 指向的对象为白色， 则标记其为灰色。 例如： 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色； 用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色； 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色； 这是一种比较保守的屏障技术，保证了强三色不变性（所有存活可能地对象都标记成灰色）。 缺点： 可以回收的 B 对象，在此次循环中不会被认为可被回收。 因为栈上的对象在垃圾收集中也会被认为是根对象，因此要为其添加写屏障，或是每次标记后针对栈上对象进行扫描。前者添加大量写入指针地额外开销，后者扫描栈对象需要停止程序。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:10","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"删除写屏障 删除写屏障会保证开启写屏障时，堆上所有对象的可达，因此也被叫做快照垃圾收集。 在老对象的引用被删除时，将白色的老对象涂成灰色，这样就保证了弱三色不变性。 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色； 用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变； 用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色； 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色； Yuasa 删除写屏障通过对 C 对象的着色，保证了 C 对象和下游的 D 对象能够在这一次垃圾收集的循环中存活，避免发生悬挂指针以保证用户程序的正确性。 ","date":"2022-04-01","objectID":"/golang%E7%AC%94%E8%AE%B0-201e1/:2:11","tags":["Go"],"title":"Golang学习笔记记录","uri":"/golang%E7%AC%94%E8%AE%B0-201e1/"},{"categories":null,"content":"这次实验主要实现 Log 的一致性和持久性。主要是 Debug 的过程中会遇到非常多的问题。这里对遇到的问题做一下回顾。这里主要是对自己的实现做一个记录和总结，常见的问题还是需要去参考 Raft 和 students-guide-to-raft。首先对论文里面的 Figure2 实现一次，再参照 guide 顺着往下阅读一遍，一边对自己的实现进行修改，就会发现自己很多实现上的 bug 了。我磕磕绊绊地做了将近两周的时间才基本把 2B 和 2C 的测试跑通。有些 Bug 在很多次重复测试后才会偶尔出现一两次，也使得调试变得比较麻烦。注意自己不要参考太多其他人的实现，那样的话有可能会被误导，还是要以论文和 guide 为主要参考。 ","date":"2021-06-15","objectID":"/mitlab2bc/:0:0","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab2BC-Raft-LogReplication-Persistence","uri":"/mitlab2bc/"},{"categories":null,"content":"定时器的实现 一开始的实现非常简陋，对定时器的实现非常不严谨，误打误撞过了 2B 的 Test，结果在 2C 的测试中吃了大苦，不得不重新回头重构定时器的机制。2B 这里主要有三个牵涉到定时的地方： Election Timer： 到时后决定是否需要发起选举。 HeartBeat Timer： Leader 在这个定时器到时后，发出 AppendEntries RPC 请求。 Append Entries timeout Timer： 心跳包的超时定时器。 一开始的定时器实现，混杂了 Loop 和 time.Sleep，甚至有些定时器会互相影响。比如一个 server 它的选举和发出心跳包的 Loop 是同一个，这样的实现无疑是非常粗糙的。最后的做法是，一个 server 在 make 后就常驻一个 CheckElection() 线程，定期用 time.Sleep() 检查是否可以发起选举。一旦满足选举的条件，再进行选举。同时使用一个 GotHeartBeat 的标志量来记录定时器的状态。这样便可以不破坏定时器的精确度。 另外当 server 成为 Leader 后，会启动 SendHeartBeat() 线程，这里的定时器实现也是与上面相似的。 另外是两个超时定时器的实现。首先需要说明为了 RPC 的并发性，回调接收是通过 channel 来进行处理的。这里的定时器也就顺理成章地使用 select 来实现了。为了正确关闭 channel，还需要使用一个回收线程去 close() 这个 channel，否则会有一大堆的阻塞的线程。 func (rf *Raft) StartElection() { rf.mu.Lock() if rf.Role != 1 { rf.mu.Unlock() return } ch := make(chan RequestVoteReply) args := RequestVoteArgs{ Term: rf.CurrentTerm, CandidateId: rf.me, LastLogIndex: len(rf.Log) - 1, LastLogTerm: rf.Log[len(rf.Log)-1].Term, } for i := 0; i \u003c len(rf.peers); i++ { if i == rf.me { continue } go rf.sendRequestVote(i, \u0026args, ch) } rf.mu.Unlock() agree := 1 randomNum := ElectionTimer + rand.Intn(50) ElectionTimeoutChan := time.After(time.Millisecond * time.Duration(randomNum)) i := 0 for { select { case reply := \u003c-ch: // DPrintf(\"server %d GOT vote reply term = %d\", rf.me, reply.Term) rf.mu.Lock() if rf.Role != 1 { rf.mu.Unlock() return } if reply.Term \u003e rf.CurrentTerm { rf.BecomeFollower(reply.Term) rf.mu.Unlock() // DPrintf(\"EXIT1\") return } else if reply.Term \u003c rf.CurrentTerm { rf.mu.Unlock() // DPrintf(\"EXIT2\") // DPrintf(\"%d \u003c %d\", reply.Term, rf.CurrentTerm) continue } else if reply.VoteGranted { agree++ // DPrintf(\"EXIT3\") } else { // DPrintf(\"EXIT4\") } if agree*2 \u003e len(rf.peers) { rf.BecomeLeader() go rf.SendHeartbeat() go rf.closeChan(i, ch) rf.mu.Unlock() // log.Fatalf(\"Leader!!!\\n\") return } rf.mu.Unlock() case \u003c-ElectionTimeoutChan: go rf.closeChan(i, ch) goto startAgain } i++ } startAgain: rf.mu.Lock() if rf.Role != 1 { rf.mu.Unlock() return } rf.BecomeCandidate() rf.mu.Unlock() go rf.StartElection() } ","date":"2021-06-15","objectID":"/mitlab2bc/:1:0","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab2BC-Raft-LogReplication-Persistence","uri":"/mitlab2bc/"},{"categories":null,"content":"快速恢复 当 Follower 的 Log 落后 Leader 很多时，可以在 Append Entries 的回复中添加 Xterm 和 XIndex 两个参数，反馈给 Leader 是哪个 term 或者哪个 index 开始落后的。这样可以快速地恢复 Follower，而不是按照 Figure2 里面那样要把 nextIndex 慢慢递减。一次递减会产生一次 RPC，这样的话有大量的冗余通信。如果不做这个优化的话，理论上不能通过 TestManyElection2A。 而我在刚开始的实现时，强制让一个 HeartBeat 去阻塞执行恢复一个 Follower 的日志。这样的话也可以通过这个测试。但是这样的设计不能通过 2C 的测试，因为这样并没有严格地实现心跳包。阻塞恢复 Log： // 这个实现是有问题的！！ // 恢复日志的实现函数 // 判断是否需要恢复，如果需要回复则创建线程去发送 AppendEntries RPC func (rf *Raft) RecoverLog(reply *AppendEntriesReply, ch chan AppendEntriesReply) bool { server := reply.Id rf.NextIndex[server]-- if rf.NextIndex[server] \u003c 1 { rf.NextIndex[server] = 1 return false } DPrintf(\"Try to recover %d nextIndex %d\", server, rf.NextIndex[server]) // retry lastIndex := rf.NextIndex[server] - 1 prevLogTerm := -1 if rf.NextIndex[server] != 0 { prevLogTerm = rf.Log[lastIndex].Term } args := AppendEntriesArgs{ rf.CurrentTerm, rf.me, lastIndex, prevLogTerm, rf.Log[rf.NextIndex[server]:], rf.CommitIndex， } go rf.sendAppliedEntries(server, \u0026args, ch) return true } // Leader 接受 AppendEntries 后 randomNum := AppendEntriesTimeout + rand.Intn(50) timeoutChan := time.After(time.Millisecond * time.Duration(randomNum)) for i := 0; i \u003c len(rf.peers)-1; i++ { // DPrintf(\"server %d waiting AppendEntriesReply\", rf.me) select { case reply := \u003c-ch: // DPrintf(\"server %d got heartbeat, id: %d\", rf.me, reply.Id) if rf.CurrentTerm != term { rf.mu.Unlock() return } if reply.Term \u003e rf.CurrentTerm { // DPrintf(\"HEARTBEAT\") rf.BecomeFollower(reply.Term) rf.mu.Unlock() return } else if reply.Term \u003c rf.CurrentTerm { continue } else if !reply.Success { DPrintf(\"Leader %d wants to recover %d\", rf.me, reply.Id) // 阻塞等待恢复日志 if rf.RecoverLog(\u0026reply, ch) { i-- } // 重置超时，等待新的 RPC 响应 timeoutChan = time.After(time.Millisecond * time.Duration(randomNum)) } case \u003c-timeoutChan: // DPrintf(\"server %d AppendEntries timeout\", rf.me) goto stopWatingHearbeat } } 这样的实现，会使得 Leader 在发现某一个 Follower 的日志落后后，就一直不断向那个 Follower 发出 AppendEntries，不断递减 nextIndex，直到 Follower 的日志不再落后为止。期间 Leader 不能对其他 Follower 发出心跳包，这样在可靠的环境下当然是可以的，但是在不可靠的网络环境下，网络的变化会使得这样的恢复行为变得没有意义。 认识到这个问题后，在 AppendEntries 的回复参数中添加快速恢复的 XTerm 和 XIndex，实现快速恢复后这个问题也就被解决了。 ","date":"2021-06-15","objectID":"/mitlab2bc/:2:0","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab2BC-Raft-LogReplication-Persistence","uri":"/mitlab2bc/"},{"categories":null,"content":"一些 guide 里面得到解决的问题 对于一些遇到的，在 guide 里面有描述的问题，这里简单做一下记录。 ","date":"2021-06-15","objectID":"/mitlab2bc/:3:0","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab2BC-Raft-LogReplication-Persistence","uri":"/mitlab2bc/"},{"categories":null,"content":"Start() 和 HeartBeat 的异同 在一开始，我认为 client 提交完一个 command 后，应该 Leader 马上去产生一堆 AppendEntries 去提交这个命令，而 HeartBeat 只是应该用于发送心跳和恢复 Follower。这样的实现确实可能没问题，但是在这两个行为里面，包含了大量雷同逻辑，实际上两者都是通过 AppendEntries 来实现的，正如 guide 里面所说，提交 command 完全可以通过 HeartBeat 来完成。 ","date":"2021-06-15","objectID":"/mitlab2bc/:3:1","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab2BC-Raft-LogReplication-Persistence","uri":"/mitlab2bc/"},{"categories":null,"content":"回应 ApplyMsg 的时机和 Commit 的一个小问题 什么时候去回应 client 呢，最直接的想法是用一个常驻线程，不断地去检查 CommitIndex 和 LastApplied。那无疑又是一些锁和资源的开销。其实只要在 CommitIndex 改变后做一次检查即可。此外，guide 中提到 Figure 8 的问题。 Leader 的 crash 可能会使得当其他的 server 成为 Leader 后，提交错误的日志。必须在 Leader 更新 CommitIndex 之前检查 rf.CurrentTerm == rf.Log[rf.CommitIndex].Term。 ","date":"2021-06-15","objectID":"/mitlab2bc/:3:2","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab2BC-Raft-LogReplication-Persistence","uri":"/mitlab2bc/"},{"categories":null,"content":"后记 经过两周的各种 Debug，除了并发测试量特别高时（比如 100 个测试并发），Figure 8 (unreliable) 会超时几秒钟以外，代码连续 5000 次通过了测试，这个 Lab 暂且算完成了。要完成这个 Lab 真的得把 Raft 的每个细节都理解清楚。非常建议使用 go-test-many.sh 脚本来并发测试，否则有些 Bug 死活测不出来，然后在某一次测试中突然跑出来闹事。另外在跑测试的时候，建议喝杯水放松放松，Bug 该来还是会来的。最后附上测试结果： Test (2A): initial election ... ... Passed -- 3.1 3 110 31908 0 Test (2A): election after network failure ... ... Passed -- 5.0 3 230 46648 0 Test (2A): multiple elections ... ... Passed -- 5.6 7 936 201618 0 PASS ok 6.824/raft 13.745s Test (2B): basic agreement ... ... Passed -- 0.7 3 16 4588 3 Test (2B): RPC byte count ... ... Passed -- 1.5 3 48 114552 11 Test (2B): agreement despite follower disconnection ... ... Passed -- 5.6 3 210 59199 8 Test (2B): no agreement if too many followers disconnect ... ... Passed -- 3.6 5 352 83558 4 Test (2B): concurrent Start()s ... ... Passed -- 0.6 3 12 3440 6 Test (2B): rejoin of partitioned leader ... ... Passed -- 4.6 3 262 59749 4 Test (2B): leader backs up quickly over incorrect follower logs ... ... Passed -- 16.2 5 2316 1827613 102 Test (2B): RPC counts aren't too high ... ... Passed -- 2.0 3 66 19678 12 PASS ok 6.824/raft 34.825s Test (2C): basic persistence ... ... Passed -- 3.9 3 126 33452 6 Test (2C): more persistence ... ... Passed -- 15.5 5 1828 369618 16 Test (2C): partitioned leader and one follower crash, leader restarts ... ... Passed -- 1.8 3 42 11544 4 Test (2C): Figure 8 ... ... Passed -- 32.2 5 1120 247514 41 Test (2C): unreliable agreement ... ... Passed -- 3.1 5 216 77507 246 Test (2C): Figure 8 (unreliable) ... ... Passed -- 94.0 5 16504 17911361 142 Test (2C): churn ... ... Passed -- 16.4 5 1296 1341742 384 Test (2C): unreliable churn ... ... Passed -- 16.2 5 888 495533 392 PASS ok 6.824/raft 183.121s ","date":"2021-06-15","objectID":"/mitlab2bc/:4:0","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab2BC-Raft-LogReplication-Persistence","uri":"/mitlab2bc/"},{"categories":null,"content":"\r警告\r这里的实现有很多的 Bug，不能跑通 2B 和 2C 的 Test。\r三个函数\r相比起 Lab1 的作业，Lab2A 作业量差不多。Lab2A 主要是围绕论文中 Figure2 的选举部分进行实现即可。 首先是有三个控制 Raft 服务器状态的函数。 func (rf *Raft) BecomeFollower(term int) { rf.currentTerm = term rf.Role = 0 rf.votedFor = -1 rf.GotHeatBeat = false DPrintf(\"term %d server %d become Follower\\n\", term, rf.me) } func (rf *Raft) BecomeCandidate() { rf.votedFor = rf.me rf.currentTerm++ rf.Role = 1 DPrintf(\"term %d server %d become Candidate\", rf.currentTerm, rf.me) } func (rf *Raft) BecomeLeader() { rf.votedFor = rf.me rf.Role = 2 for i := 0; i \u003c len(rf.peers); i++ { rf.MatchIndex[i] = 0 rf.NextIndex[i] = len(rf.log) } DPrintf(\"term %d server %d become Leader\", rf.currentTerm, rf.me) } 三个函数负责 server 状态的切换。注意这三个函数都是没有加锁的，需要在调用的地方加锁。 接着是对 Figure2 中需要保存的状态变量进行定义，这里就不放出详细代码了比较简单。最后就是实现 RequestVote 和 AppendEntries。注意需要详细结合 Figure2 里面的策略，否则会出现意想不到的 bug （通常难以解释或者难以自己想出正确的策略）。 选举相关策略\r对所有的 server： 若任何通信中发现了 term \u003e currentTerm 的情况，都将所在的 server 设置为 currentTerm = term 的 follower。无论当前 server 是什么角色。 对 followers： 回应所有 RPC 请求 如果选举定时器超时，仍然没有受到 AppendEntries，则转换为 candidate 开始举行选举投票。 对 candidates： 变成 candidate 后开始选举 如果收到大部分的选票支持，则成为 Leader。 如果收到一个 AppendEntries, 则变成 follower。 如果选举超时，则重新开始选举。 对 leader： 定时发送 AppendEntries 到所有 server， 防止他们的选举定时器超时。 在我的实现中，大部分的锁都是函数级别的，没有把粒度分得很细。定时器除了使用 for 和 sleep 来实现以外，两个 RPC 的接收也使用了定时器来防止超时，这里的定时器使用 channel 和 select 来实现，可以和 RPC 的接收一起实现，更加简洁。这里给出最核心的 ticker 函数。 func (rf *Raft) ticker() { for !rf.killed() { randomNum := 100 + rand.Intn(100) time.Sleep(time.Millisecond * time.Duration(randomNum)) rf.mu.Lock() if !rf.GotHeatBeat \u0026\u0026 rf.Role == 0 { rf.BecomeCandidate() agrees := 1 ch := make(chan RequestVoteReply) args := RequestVoteArgs{rf.CurrentTerm, rf.me, rf.CommitIndex, rf.CurrentTerm - 1} for i := 0; i \u003c len(rf.peers); i++ { if i == rf.me { continue } go rf.sendRequestVote(i, \u0026args, ch) } waiting := true for i := 0; i \u003c len(rf.peers) \u0026\u0026 waiting; i++ { if rf.Role != 1 { break } select { case reply := \u003c-ch: if reply.VoteGranted { agrees++ } if reply.Term \u003e rf.CurrentTerm { rf.BecomeFollower(reply.Term) waiting = false } case \u003c-time.After(time.Millisecond * 300): DPrintf(\"term %d server %d election timeout\\n\", rf.CurrentTerm, rf.me) waiting = false } if agrees*2 \u003e len(rf.peers) { break } } if agrees*2 \u003e len(rf.peers) { rf.BecomeLeader() } else { rf.BecomeFollower(rf.CurrentTerm - 1) } } // DPrintf(\"server %d end first stage\\n\", rf.me) rf.GotHeatBeat = false rf.mu.Unlock() term, isLeader := rf.GetState() for isLeader { ch := make(chan AppendEntriesReply) args := AppendEntriesArgs{term, rf.me, 0, 0, rf.log, rf.CommitIndex} for i := 0; i \u003c len(rf.peers); i++ { go rf.sendAppliedEntries(i, \u0026args, ch) } waiting := true for i := 0; i \u003c len(rf.peers) \u0026\u0026 waiting; i++ { // DPrintf(\"server %d waiting AppendEntriesReply\", rf.me) select{ case reply := \u003c-ch: // DPrintf(\"server %d got AppendEntriesReply, term: %d\", rf.me, reply.Term) rf.mu.Lock() if reply.Term \u003e rf.CurrentTerm { rf.BecomeFollower(reply.Term) waiting = false } rf.mu.Unlock() case \u003c- time.After(time.Millisecond * 500): waiting = false } } time.Sleep(time.Millisecond * 100) term, isLeader = rf.GetState() } } } 结果：\r运行 go test -run 2A Test (2A): initial election ... ... Passed -- 3.1 3 87 21200 0 Test (2A): election after network failure ... ... Passed -- 4.5 3 90 17216 0 Test (2A): multiple elections ... ... Passed -- 7.5 7 625 100826 0 PASS ok 6.824/raft 15.106s 测试通过。 ","date":"2021-06-08","objectID":"/mit-6.824-lab2a-raft-leaderelection/:0:0","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab2A-Raft-LeaderElection","uri":"/mit-6.824-lab2a-raft-leaderelection/"},{"categories":null,"content":"这次实验的目的是自己完成一个 MapReduce 的分布式实现。对我来说最大的困难在于语言的不熟悉，这里主要使用的是 Go 语言。由于这是我第一次接触 Go，有很多实现细节其实可以做的更好一些。 ","date":"2021-06-02","objectID":"/mit-6.824-lab1-mapreduce-%E5%AE%9E%E9%AA%8C/:0:0","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab1-MapReduce 实验","uri":"/mit-6.824-lab1-mapreduce-%E5%AE%9E%E9%AA%8C/"},{"categories":null,"content":"基本要求 master 进程分配 m 个 Map 任务和 n 个 Reduce 任务给 worker，worker 完成任务后通知 master。 若 worker 完成的是 Map 任务，则完成后把结果返回给 master，master 做哈希映射到 n 个 Reduce 模块。若完成的是 Reduce 任务，则写入磁盘后通知 master 任务已完成。 Reduce 任务需要等到所有 Map 任务完成后再执行。 为了通过最后的 crash 测试，当 worker 超时，master 会分配新的 worker 去完成任务。这里需要保证对分配重复任务的 worker，只取一次的结果。 Task RPC\r本着简单实现的想法，设计了以下 RPC 结构。 type Task struct { Seq int Status int // 0 1 2 3 4 MapFile string ReduceFiles []KeyValue LastTime time.Time } 这样就可以完整描述一个 Map 任务或者是一个 Reduce 任务了。 master\r接着是 master 的结构设计。 type Coordinator struct { TaskQueue []Task NReduce int MapFinished bool ReduceFinished bool RemainMapTask int RemainReduceTask int Mu sync.Mutex } 这里用一个数组来记录任务队列。MapFinished 和 ReduceFinished 代表的是 Map 任务是否已经全部完成以及 Reduce 任务是否已经全部完成。 More RPC\r设计两个 RPC 接口，一个是请求任务的接口，一个是通知完成任务的接口。注意这里使用 checkTime() 函数来检查任务是否超时，一旦超时，则分配新的 worker 去完成任务。为了简化处理，这里没有对超时的 woker 做回收，而是忽略它通知完成任务的行为。 func checkTime(oldTime time.Time) bool { m, _ := time.ParseDuration(\"-10s\") m1 := time.Now().Add(m) if m1.After(oldTime) { fmt.Println(\"delay occurs\") } return m1.After(oldTime) } func (c *Coordinator) RequestForTask(request int, reply *Task) error { // fmt.Printf(\"%d ask for Task, Map Remaining %d, Reduce Remaining %d\\n\", request, c.RemainMapTask, c.RemainReduceTask) c.Mu.Lock() defer c.Mu.Unlock() if !c.MapFinished { for i := c.NReduce; i \u003c len(c.TaskQueue); i++ { if c.TaskQueue[i].Status == 0 || (c.TaskQueue[i].Status == 1 \u0026\u0026 checkTime(c.TaskQueue[i].LastTime)){ c.TaskQueue[i].Status = 1 c.TaskQueue[i].LastTime = time.Now() *reply = c.TaskQueue[i] return nil } } } else if !c.ReduceFinished { for i := 0; i \u003c c.NReduce; i++ { if c.TaskQueue[i].Status == 2 || (c.TaskQueue[i].Status == 3 \u0026\u0026 checkTime(c.TaskQueue[i].LastTime)) { c.TaskQueue[i].Status = 3 c.TaskQueue[i].LastTime = time.Now() *reply = c.TaskQueue[i] return nil } } } if !c.ReduceFinished { (*reply).Seq = -1 } else { (*reply).Seq = -2 } return nil } func (c *Coordinator) SubmmitTask(t Task, p *int) error { c.Mu.Lock() defer c.Mu.Unlock() if c.TaskQueue[t.Seq].Status == -1 { return nil } status := t.Status // fmt.Println(c.TaskQueue[seq].ReduceFiles) if status == 1 { // fmt.Printf(\"Receving %s\\n\", t.MapFile) for _, wi := range t.ReduceFiles { i := ihash(wi.Key) % c.NReduce c.TaskQueue[i].ReduceFiles = append(c.TaskQueue[i].ReduceFiles, wi) } c.RemainMapTask-- if c.RemainMapTask == 0 { c.MapFinished = true } } else if status == 3 { c.RemainReduceTask-- if c.RemainReduceTask == 0 { c.ReduceFinished = true } } c.TaskQueue[t.Seq].Status = -1 return nil } 使用 ./test-mr.sh 测试，结果如下 ./test-mr.sh ../../mrapps/wc.so *** Starting wc test. 2021/06/02 17:49:08 rpc.Register: method \"Done\" has 1 input parameters; needs exactly three --- wc test: PASS ../../mrapps/indexer.so *** Starting indexer test. 2021/06/02 17:49:18 rpc.Register: method \"Done\" has 1 input parameters; needs exactly three --- indexer test: PASS *** Starting map parallelism test. 2021/06/02 17:49:24 rpc.Register: method \"Done\" has 1 input parameters; needs exactly three --- map parallelism test: PASS *** Starting reduce parallelism test. 2021/06/02 17:49:33 rpc.Register: method \"Done\" has 1 input parameters; needs exactly three --- reduce parallelism test: PASS *** Starting job count test. 2021/06/02 17:49:44 rpc.Register: method \"Done\" has 1 input parameters; needs exactly three --- job count test: PASS *** Starting early exit test. 2021/06/02 17:50:03 rpc.Register: method \"Done\" has 1 input parameters; needs exactly three --- early exit test: PASS *** Starting crash test. ../../mrapps/nocrash.so 2021/06/02 17:50:12 rpc.Register: method \"Done\" has 1 input parameters; needs exactly three delay occurs delay occurs delay occurs delay occurs delay occurs delay occurs 2021/06/02 17:50:51 dialing:dial unix /var/tmp/824-mr-1000: connect: connection refused 2021/06/02 17:50:51 dialing:dial unix /var/tmp/824-mr-1000: connect: connection refused 2021/06/02 17:50:51 dialing:dial unix /var/tmp/824-mr-1000: connect: connection refused --- crash test: PASS *** PASSED ALL","date":"2021-06-02","objectID":"/mit-6.824-lab1-mapreduce-%E5%AE%9E%E9%AA%8C/:1:0","tags":["Distributed System","Go"],"title":"MIT-6.824-Lab1-MapReduce 实验","uri":"/mit-6.824-lab1-mapreduce-%E5%AE%9E%E9%AA%8C/"},{"categories":null,"content":"随着计算机在数量上的增加，计算机同样开始分散。尽管商业公司过去愿意购买越来越大的大型机，现在的典型情况是，甚至很小的应用程序都同时在多台机器上运行。思考这样做的利弊权衡，即是分布式系统的研究所在，也是越来越重要的一项技能。 概述 ","date":"2021-05-27","objectID":"/gfs/:0:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"介绍 需要分布式的原因： 并行性 容错性 物理性 安全性 基本的挑战： 并行性带来的复杂 部分故障 最终性能 ","date":"2021-05-27","objectID":"/gfs/:1:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"实现工具 RPC 多线程 多并发控制（锁） ","date":"2021-05-27","objectID":"/gfs/:1:1","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"性能-可拓展性加速 最好的结果是，线性地增长设备时，性能也能线性地提升（甚至指数性）。 ","date":"2021-05-27","objectID":"/gfs/:2:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"容错 计算机会经常故障或者挂掉（集群）。这要求系统拥有可用性和恢复性。 可用性: 服务在以上这些挑战下，还是可用的。 可恢复性：出现问题时，服务是可恢复的。 解决工具： 非易失性存储（硬盘）。通常很慢。 复制副本。 ","date":"2021-05-27","objectID":"/gfs/:3:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"一致性 存储→key-value表。 put 和 get 会在多副本中产生一些列一致性的问题。 ","date":"2021-05-27","objectID":"/gfs/:4:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"MapReduce 假设有一些输入块，每个输入块经过一个 Map 函数，得到一些 key。Reduce 部分是指把每个输入块得到的 key，集合起来，相同的 key 传递给一个 Reduce 函数，Reduce 函数负责把这些数据归合起来。最后分别计算数据。 Go ","date":"2021-05-27","objectID":"/gfs/:5:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"使用多线程 ","date":"2021-05-27","objectID":"/gfs/:6:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"好处： IO 资源共享 并行性 周期性检查 事件驱动友好 ","date":"2021-05-27","objectID":"/gfs/:6:1","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"挑战： 共享变量带来的 race 问题 ","date":"2021-05-27","objectID":"/gfs/:6:2","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"coordination协调手段 channels 频道 sync.Cond 条件变量 waitGroup 等待队列 Deadlock 死锁 GFS Google File System-GFS 论文阅读 ","date":"2021-05-27","objectID":"/gfs/:7:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"大数据存储的难题 性能表现 →分片分机 分片分机 →容错 容错度→副本复制 副本复制→消除一致性问题 一致性→低性能 ","date":"2021-05-27","objectID":"/gfs/:8:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"一个副本的情况 考虑存储一个键值表。 一个副本下，也会出现一些简单的一致性的问题 同时容错率极低，单主机崩溃后 server 直接 down。 ","date":"2021-05-27","objectID":"/gfs/:9:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"两个副本的情况 两个副本下， client 直接向两台服务器同时发送请求。若不能保证client 请求的顺序相同，一致性就会被破坏。 ","date":"2021-05-27","objectID":"/gfs/:10:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"GFS 的解决方案 The Google File System中文版.pdf 特点： Big，Fast，Global（共享） 分割文件：从大文件到小文件。 自动化恢复 单一的数据中心（Google 内部使用的服务） 为大范围的非随机访问优化 设计： 客户端发送文件名和 chunk index，master 服务器做 map 工作，把 IO 工作分到不同 chunkserver，不同的 chunkserver 带来并行性提高性能。 master 需要保存的信息： 文件名→array of chunk handles （nv） chunk handles version chunk 的版本号 （nv） list of chunk servers （memory） primary （memory） lease time 过期时间 （memory） log + checkpoint （stable storage 先写入 log 再执行写入操作） ","date":"2021-05-27","objectID":"/gfs/:11:0","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"读操作 client 发送 filename 和 offset 到 master master 找到 list of chunkservers client 会对某些 chunk server 发送读请求，且会把 chunk server缓存起来 chunk server 读取文件，返回数据 ","date":"2021-05-27","objectID":"/gfs/:11:1","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"写操作 当 master 没有 primary 时： 找到最新副本的 chunk server 选择一个作为 primary 增加版本号，写入 告诉 primary 和 secondary，需要增加版本号 master 把新的 version 写入硬盘 primary 告诉所有的 secondary，需要追加写入文件 如果所有的 secondary 都回应 yes，那么向 client 回应 success，否则回应 failed。这里如果某个 secondary 写入失败，其他的 secondary 仍然会写入，这里会产生不一致性的问题。但是 GFS 容忍这种不一致性（冗余）。同时 client 会重试请求。 当 master 有 primary 时，不会更新版本号。 ","date":"2021-05-27","objectID":"/gfs/:11:2","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"split brain 脑裂问题 当网络错误使得 master 无法和 primary 通信，master 会重新指定一个 primary，此时会产生两个 primary。此时 client 直接向两个 primary 发送信息时，就会产生冲突。 解决方法：当 master 需要重新选择 primary 时，master 会等待上一个 primary 的 lease（租约）过期，再去分配新的 primary。 ","date":"2021-05-27","objectID":"/gfs/:11:3","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"缺点 GFS 只有一个 master，而单个 master 的内存资源总是有限的。 ","date":"2021-05-27","objectID":"/gfs/:11:4","tags":["Distributed System"],"title":"GFS文件系统","uri":"/gfs/"},{"categories":null,"content":"在 CSAPP 中，说到在操作系统的线程概念模型中，每个线程有独立的栈，而线程之间不能访问其他栈的变量。 概念模型\r线程独享有： 线程 ID 栈 栈指针 PC 程序计数器 条件状态位 寄存器 不独享的有： 指令代码 .data 堆 shared library 但是在实际的实现中，事情会变得不一样。 实际实现\r线程实际独立的东西只有： 线程 ID PC 程序计数器 栈指针 寄存器 条件状态位 而且线程之间的栈可以互相访问。 为了探究这一特性，做了相关的测试代码。 /* * 创建两个全局指针 a，b，首先由 线程 1 修改两个指针分别指向堆变量和栈变量 * 线程 2 分别访问两个指针指向的地址，检验堆变量和栈变量的可访问性 */ #include \u003cdbg.h\u003e #include \u003cpthread.h\u003e int* a = nullptr; int *b = nullptr; void* fun1(void*) { sleep(1); dbg(\"------1s------\"); dbg(a = new int(1000)); int c = 200; dbg(b = \u0026c); return nullptr; } void* fun2(void*) { dbg(a); dbg(b); sleep(2); dbg(\"------2s------\"); dbg(a, *a); dbg(b, *b); return nullptr; } int main() { pthread_t p1, p2; pthread_create(\u0026p1, nullptr, fun1, nullptr); pthread_create(\u0026p2, nullptr, fun2, nullptr); pthread_join(p2, nullptr); } 提示：\r推荐使用 \u003ca href=“https://github.com/sharkdp/dbg-macro\"target=\"_blank\" rel=“external nofollow noopener noreferrer”\u003edbg-macro 方便地输出调试信息。\r结果在 Ubuntu 18.0 中，测试结果如下 [test.cpp:19 (fun2)] a = nullptr (int*) [test.cpp:20 (fun2)] b = nullptr (int*) [test.cpp:9 (fun1)] ------1s------ [test.cpp:11 (fun1)] a = new int(1000) = 0x7fa154000e10 (int*\u0026) [test.cpp:13 (fun1)] b = \u0026c = 0x7fa162597e64 (int*\u0026) [test.cpp:23 (fun2)] ------2s------ [test.cpp:25 (fun2)] a = 0x7fa154000e10 (int*) [test.cpp:25 (fun2)] *a = 1000 (int\u0026) [test.cpp:26 (fun2)] b = 0x7fa162597e64 (int*) [test.cpp:26 (fun2)] *b = 200 (int\u0026) 在 Mac OS X 中 测试结果如下 [test.cpp:19 (fun2)] a = nullptr (int*) [test.cpp:20 (fun2)] b = nullptr (int*) [test.cpp:9 (fun1)] ------1s------ [test.cpp:11 (fun1)] a = new int(1000) = 0x7f81c4d040d0 (int*\u0026) [test.cpp:13 (fun1)] b = \u0026c = 0x7000003f6e9c (int*\u0026) [test.cpp:23 (fun2)] ------2s------ [test.cpp:25 (fun2)] a = 0x7f81c4d040d0 (int*) [test.cpp:25 (fun2)] *a = 1000 (int\u0026) [test.cpp:26 (fun2)] b = 0x7000003f6e9c (int*) [1] 54143 segmentation fault \"/Users/lulu/Desktop/code/\"test 结果：\r说明在 Mac OS X 中，线程之间的栈不能相互访问，而在 Ubuntu 中，线程之间可以访问各自的栈变量。而两个系统环境下，不同线程下可以互相访问各自的 heap 变量。\r","date":"2021-05-22","objectID":"/linux%E4%B8%8B%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%A0%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%A0%86%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B1%E4%BA%AB%E6%80%A7/:0:0","tags":["Linux","CS"],"title":"Linux下线程中栈变量和堆变量的共享性","uri":"/linux%E4%B8%8B%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%A0%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%A0%86%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B1%E4%BA%AB%E6%80%A7/"},{"categories":null,"content":"在《Effective C++》中，作者提到绝对不要在构造函数和析构函数中调用虚函数。在构造函数和析构函数中，虚机制是失效的，调用的永远是该析构函数所在类的对应函数。网上提出一些解释说明： 这个是未定义行为。vs下的类的首地址的内容为虚表指针，占4个或者8个字节，取决于是32位还是64位程序。在基类初始化时，虚表指针指向基类虚表，子类初始化时，将其改写为子类虚表地址。因此在基类中调用虚方法一定是调用了基类的虚函数。析构函数中也一样，只不过虚表指针的改写顺序是相反的。所以无论如何不要在析构函数或者构造函数中调用虚函数。 #include \u003cdbg.h\u003e using namespace std; class A { public: A() {dbg(\"A()\");} ~A() {dbg(\"~A()\");} }; class Base { public: A a; Base() {dbg(\"Base()\");run();} ~Base() {dbg(\"~Base()\");run();} virtual void run() {dbg(\"father virtual function called.\");} }; class Derived: public Base { public: void run() {dbg(\"child virtual function called.\");} Derived() { dbg(\"Derived()\"); run();} ~Derived() {dbg(\"~Derived()\"); run();} }; int main() { Derived b; } 运行结果： [test.cpp:6 (A)] A() [test.cpp:13 (Base)] Base() [test.cpp:15 (run)] father virtual function called. [test.cpp:21 (Derived)] Derived() [test.cpp:20 (run)] child virtual function called. [test.cpp:22 (~Derived)] ~Derived() [test.cpp:20 (run)] child virtual function called. [test.cpp:14 (~Base)] ~Base() [test.cpp:15 (run)] father virtual function called. [test.cpp:7 (~A)] ~A() 可以看到虚机制失效，且能看出来构造函数的调用顺序为：基类构造函数、对象成员构造函数、派生类本身的构造函数。 ","date":"2021-05-17","objectID":"/%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E5%A6%82%E4%BD%95/:0:0","tags":["C++"],"title":"在构造函数和析构函数中调用虚函数会如何","uri":"/%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E5%A6%82%E4%BD%95/"},{"categories":null,"content":"在 STL 中，unordered_set 需要所选对象具有哈希函数，而 set 要求所选对象的 key 有比较大小的函数。本文就来简单展开讨论。 ","date":"2021-05-12","objectID":"/stl-hash-map/:0:0","tags":["C++","STL"],"title":"STL 中如何为自定义的类编写比较函数和哈希函数","uri":"/stl-hash-map/"},{"categories":null,"content":"自定义哈希函数 unordered_set 的底层为 hashtable，解决哈希冲突的方法为链表法。默认的哈希函数定义为 hash\u003ckey\u003e。我们可以自定义一个 hash 函数例如： #include \u003cunordered_set\u003e #include \u003ciostream\u003e using namespace std; class A { public: A(int aa, int bb): a(aa), b(bb) {} char a; int b; }; class hash_funA { public: int operator()(const A \u0026a) const { return a.a + a.b; } }; class equalA { //仿函数，比较两个对象是否相同 public: bool operator()(const A\u0026 a, const A\u0026 b) const { return a.a == b.a \u0026\u0026 a.b == b.b; } }; int main() { unordered_set\u003cA, hash_funA, equalA\u003e s; for(int i = 0; i \u003c 100; ++i) s.insert(A(i, i)); } 其基本原理是：使用一个数组，把 key 映射到某个数组下标，就把对象存放在那个数组下标上。但是会发生哈希冲突的问题。因此哈希表的插入过程为： 得到 key 算出 hash 求模后得到 index 存放对象 取出过程相似： 从 key 得到 hash 求模后得到 index 检查 index的元素是否与 key 相同。 取出对象 那么为什么需要比较两个对象是否一样的 equalA 呢。答案是因为多个 key 可能对应相同的 hash，因此一个查到对应的桶之后，需要检查桶里面的 key 是否与 key 真的一致，这就需要euqalA了。 或者这里也不需要 equalA，直接在类内定义一个==的重载函数即可。 class A { public: A(int aa, int bb): a(aa), b(bb) {} char a; int b; bool operator==(const A\u0026 other) const { return other.a == a \u0026\u0026 other.b == b; } }; ","date":"2021-05-12","objectID":"/stl-hash-map/:1:0","tags":["C++","STL"],"title":"STL 中如何为自定义的类编写比较函数和哈希函数","uri":"/stl-hash-map/"},{"categories":null,"content":"自定义比较函数 我们在使用 set 时，若是自定义类的话，需要定义类的比较函数。 #include \u003cset\u003e #include \u003ciostream\u003e using namespace std; class A { public: A(int aa, int bb): a(aa), b(bb) {} char a; int b; bool operator\u003c(const A\u0026 other) const { return (a == other.a)? b \u003c other.b: a \u003c other.a; } }; int main() { set\u003cA\u003e s; for(int i = 0; i \u003c 100; ++i) s.insert(A(i, i)); } 同样是通过操作符重载来实现。 ","date":"2021-05-12","objectID":"/stl-hash-map/:2:0","tags":["C++","STL"],"title":"STL 中如何为自定义的类编写比较函数和哈希函数","uri":"/stl-hash-map/"},{"categories":null,"content":"shared_ptr 主要依赖一个引用计数指针和一个 mutex 锁来实现管理对象生命周期。 ","date":"2021-05-12","objectID":"/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:0:0","tags":["C++"],"title":"实现shared_ptr","uri":"/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":null,"content":"code #include \u003ciostream\u003e #include \u003cmutex\u003e using namespace std; template\u003ctypename T\u003e class myshared_ptr { public: myshared_ptr(T* ptr) : realPtr(ptr), refCount(new int(1)), lock(new mutex) { cout \u003c\u003c \"construct, refCount: 1\" \u003c\u003c endl; } myshared_ptr(const myshared_ptr\u003cT\u003e\u0026 other) : realPtr(other.realPtr), refCount(other.refCount), lock(other.lock) { lock-\u003elock(); ++(*refCount); cout \u003c\u003c \"refCount: \" \u003c\u003c *refCount \u003c\u003c endl; lock-\u003eunlock(); } T\u0026 operator*() { return *realPtr; } T* operator-\u003e() { return realPtr; } ~myshared_ptr() { lock-\u003elock(); --(*refCount); if(*refCount == 0) { delete realPtr; cout \u003c\u003c \"delete realPtr\" \u003c\u003c endl; lock-\u003eunlock(); delete lock; return; } lock-\u003eunlock(); } private: const myshared_ptr\u003cT\u003e\u0026 operator=(const myshared_ptr\u003cT\u003e other) { } private: T* realPtr; int* refCount; mutex* lock; }; class A { public: int val; char c; }; void fun() { myshared_ptr\u003cA\u003e aPtr(new A); myshared_ptr\u003cA\u003e bPtr = aPtr; aPtr-\u003eval = 101; aPtr-\u003ec = 'Y'; cout \u003c\u003c (*aPtr).val \u003c\u003c \" \" \u003c\u003c (*bPtr).c \u003c\u003c endl; } int main() { fun(); } ","date":"2021-05-12","objectID":"/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:1:0","tags":["C++"],"title":"实现shared_ptr","uri":"/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":null,"content":"上次面试被问到了偏特化的使用, 现在来总结一下C++里面偏特化的用法。 ","date":"2021-05-11","objectID":"/c-%E5%81%8F%E7%89%B9%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["C++","Template"],"title":"C++偏特化的使用","uri":"/c-%E5%81%8F%E7%89%B9%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"类模板 类在不同的模板下，数据成员可以不同。每一份模板参数生成一份代码，这个过程发生在编译期。编译器会针对每一份模板参数生成一份代码，且对静态的数据成员，不同的模板下的静态数据成员独立存储。 类可以被全特化，也可以被偏特化。类的成员函数可以被全特化。 ","date":"2021-05-11","objectID":"/c-%E5%81%8F%E7%89%B9%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["C++","Template"],"title":"C++偏特化的使用","uri":"/c-%E5%81%8F%E7%89%B9%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"函数模板 函数模板的用法与类类似，但是函数模板不能偏特化。原因： C++标准没有规定，而且函数重载可以实现偏特化的效果。 ","date":"2021-05-11","objectID":"/c-%E5%81%8F%E7%89%B9%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","tags":["C++","Template"],"title":"C++偏特化的使用","uri":"/c-%E5%81%8F%E7%89%B9%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"code #include \u003ciostream\u003e using namespace std; template \u003ctypename A, typename B\u003e class Basic { public: A a; B b; void run() { cout \u003c\u003c \"run from Basic\u003cA, B\u003e\" \u003c\u003c endl; } }; template \u003c\u003e void Basic\u003cbool, bool\u003e::run() { cout \u003c\u003c \"run from Basic\u003cbool, bool\u003e\" \u003c\u003c endl; } template \u003ctypename B\u003e class Basic\u003cint, B\u003e { public: double a; B b; void run() { cout \u003c\u003c \"run from Basic\u003cint, B\u003e\" \u003c\u003c endl; } }; template \u003ctypename A, typename B\u003e void f() { cout \u003c\u003c \"\u003cA, B\u003e\" \u003c\u003c endl; } template \u003c\u003e void f\u003cint, char\u003e() { cout \u003c\u003c \"\u003cint, char\u003e\" \u003c\u003c endl; } int main() { Basic\u003cint, char\u003e a; Basic\u003cchar, char\u003e aa; a.a = 1.1; aa.a = 'a'; cout \u003c\u003c a.a \u003c\u003c endl; cout \u003c\u003c aa.a \u003c\u003c endl; a.run(); aa.run(); Basic\u003cbool, bool\u003e().run(); f\u003cint, int\u003e(); f\u003cint, char\u003e(); } //函数不能偏特化，可以通过函数重载实现偏特化的目的 ","date":"2021-05-11","objectID":"/c-%E5%81%8F%E7%89%B9%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/:3:0","tags":["C++","Template"],"title":"C++偏特化的使用","uri":"/c-%E5%81%8F%E7%89%B9%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"数据链路层（逻辑链路层） 数据链路层包含逻辑链路层和 MAC 子层. ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"数据链路层的流量控制 差错检测和控制 流量控制 基于速率 基于反馈（由接收方反馈信息给发送方） ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"数据结构（帧） 帧=帧头+载荷+帧尾 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"帧头 物理地址信息 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:1","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"帧尾 校验和 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:2","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"成帧的方法 字符计数法（头部添加帧长） 字节填充的标志字节法（每一帧采用特殊的字符作为帧界 flag byte） 使用转义符解决标志字节法的问题，实际用于PPP 协议中 比特填充的比特标记法解决这个问题。（5 个 1 后面加一个 0） 或者使用冗余的信号作为帧界 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"差错处理（纠错、检错） 纠错码主要用于无线网络（冗余开销大） 检错码可以发现错误，使用在局域网中，使用重传恢复。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"海明距离 两个码字之间的海明距离为不同位的个数。 可以使用异或计算，再统计 1 的个数。 全部码字的海明距离定义为任意两个码字之间海明距离的最小值。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:1","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"海明距离的意义 如果海明距离为 d，则一个码字需要发生 $d$ 个 1 位错误才能变成另外一个码字。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:2","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"海明距离与检错 海明距离为 $d+1$ 的编码可以检测出 d 位差错。 一个码字至少要变 $d+1$ 次才能变为另外一个码字。 海明距离代表了需要检错的数据位的成本开销。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:3","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"海明距离与纠错 海明距离为 $2d+1$ 的编码，可以纠错 $d$ 位差错。 它可以选择海明距离最低的码字进行纠正。 海明距离越大，纠错能力越强。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:4","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"纠一位错的海明码 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:5","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"检一位错的海明码 奇偶校验码（添加一位，保证 1 位奇数或者偶数个） 互联网校验和（常见的 16 位补码互联网校验和） 循环冗余校验码CRC（使用异或运算，检查多项式是否能被通用的生成多项式CRC32整除） ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:6","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"基本协议 无限制的单工协议（乌托邦协议） 半双工协议（有反馈机制，等待上一个帧的收到回应后，再发送下一个帧） 肯定确认重传（确认正确帧，超时重发，添加序列号） ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:5:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"滑动窗口 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:6:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"协议 4：滑动窗口协议 窗口大小为 1 发送窗口：已经发送未被确认的序号 接收窗口：期望接收的序列号 seq 使用一个位来表示，0，1 交替出现。 存在问题：定时器设置过短的时候，会产生很多重复帧。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:6:1","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"协议 5：回退 n 帧 当某一个帧出错时，重传从那个帧开始之后的所有帧。 采用了累计确认。 定义 seq 和滑动窗口 发送方连续发送，直到发送窗口满 接收窗口为 1，对出错帧不确认（引发超时） 发送方超时重传，从未被确认的帧开始 存在问题：maxSeq 的混搅 解决方法：发送窗口小于 maxSeq。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:6:2","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"协议 6：选择重传 当某一个帧出错时，重传那个帧。 使用否定确认 NAK（告诉发送方某帧出错，而不是等超时） 接收窗口：$W=(maxSeq+1)/2$。保证新老窗口不重复即可。 数据链路层（MAC 子层） ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:6:3","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"介质的多路访问控制 静态分配：预先分配给各个用户。 动态分配：信号是开放的。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:7:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"多路访问协议 随机访问协议 ALOHA CSMA CSMA/CD（以太网） 受控访问协议 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:7:1","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"ALOHA 纯 ALOHA（冲突后等待随机时间） 分隙 ALOHA（把时间分成时隙，占用后发送） ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:7:2","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"CSMA（改进的 ALOHA） 非持续式（介质如果忙，等待一个随机分布时间后再询问） 持续式（如果介质忙，持续侦听） 1-持续（如果空闲时，直接发送） p-持续（如果空闲时，以 $P$ 的概率发送） ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:7:3","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"冲突窗口 RTT 定义为两个最远工作站的传输时间（两个帧时）。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:7:4","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"CSMA/CD（带冲突检测的 CSMA） 实际上是一个 1 持续的 CSMA。 先听后发，边发边听。 若介质忙，持续监听，空闲立即发送。 发送的同时监听自己的信号，若不一致，停止帧的发送，并发出一个拥塞信号。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:7:5","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"冲突检测 以太网 以太网位于数据链路层和物理层。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:7:6","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"IEEE ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:8:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"以太网采用曼彻斯特编码的CSMA/CD 技术 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:9:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"IEEE802.3 以太网帧（区别于 DIX 以太网帧） 前导码+11 一共 64bit（8 bytes） 目的地址和源地址都是 MAC 地址。 以太网：类型（上层使用的协议） IEEE：数据长度（64 字节~1518 字节，只不包括前导码） 数据（46~1500 字节） 校验和（CRC 冗余校验，除了前导码以外的校验。4 个字节） ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:10:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"为什么帧长度要大于 64bytes CSMA/CD 要求最短帧的发送时间大于等于争用时隙。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:10:1","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"二层交换的原理 网桥（交换机）负责二层交换，不会检查网络层，只做转发。 通过透明网桥把多个 LAN 连接起来。 透明网桥接收所有的帧，并决定丢弃还是转发。 决策是通过网桥内部的地址表的目的 MAC 地址来做出的。 当找不到地址时，广播这个帧。 收到一个帧，会学习帧的源地址。 网桥分割了区域，又提高了性能。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:11:0","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"生成树算法 STP 生成无环的树，防止网络风暴、多帧传送、MAC 地址库不稳定。 ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:11:1","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"两层交换设备 以太网卡（具有发送和监听的功能） 网桥（连接不同的 LAN） 交换机（多端口的网桥） 工作原理： flooding：泛洪 forwarding: 转发 filtering：过滤 learning：学习 存储转发（来得及校验） 直接转发（来不及校验） 无分片交换（读够 64 个字节后再转发） ","date":"2021-05-10","objectID":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:11:2","tags":["Networks"],"title":"数据链路层复习","uri":"/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"这里主要讨论 InoDB 下的 MySQL。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:0:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"事务及实现原理 参考文章 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:1:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"四大特性 原子性 一致性 隔离性 持久性 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:1:1","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"可能出现的问题 幻读 一个事务的两次不同时间的相同查询返回了不同的的结果集。例如:一个 select 语句执行了两次，但是在第二次返回了第一次没有返回的行,那么这些行就是“phantom” row。 例如：银行在做统计报表时统计account表中所有用户的总金额时候，此时总共有三个账户，总共金额为3000元，这时候新增了一个用户账户，并且存入1000元，这时候银行再次统计就会发现账户总金额为4000，造成了幻读情况。 不可重复读 一个事务内重复读某一行数据，读到的数据不一样。 更新丢失 两个事务对同一个数据操作后，一个事务的操作数据丢失。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:1:2","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"事务的隔离级别 读未提交（Read Uncommited） 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。（write mutex） 幻读、不可重复读、更新丢失 授权读取（Read Committed） 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。 不可重复读取和虚读，但避免脏读取。 可重复读取（Repeatable Read）(mysql默认级别) 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 可能会出现幻读和虚读。 序列化（Serializable） 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞 Innodb ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:2:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"实现架构 Master线程主要负责把脏数据同步到硬盘，保持数据的一致性。 IO线程主要负责io的回调，read、write、insert buffer、logIO。 Purge线程负责回收过期的redo log。 Page Cleaner负责把对脏页的操作从主线程中分离开来，提高效率。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:3:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"内存数据对象 使用LRU算法来缓冲，提高性能。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:4:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"Checkpoint技术 为了防止数据丢失，事务数据库都采用write ahead log，先写log再写。符合持久化的要求。 Checkpoint技术解决了以下问题： 缩短数据库恢复时间 缓冲池不够用时，把脏页刷新到硬盘 重做日志不可用时，刷新脏页到日志的状态 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:5:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"关键技术 插入缓冲 两次写 自适应哈希索引 异步IO 刷新邻接页 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:6:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"insert buffer 把多索引的随机访问化为一次性的顺序访问，对机械硬盘性能的影响巨大。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:6:1","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"两次写 写时先把脏页复制到dubble write buffer，然后修改完后写到共享表，马上调用fsync同步到硬盘。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:6:2","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"自适应哈希 AHI innodb会自动对能提高性能的列建立哈希索引。 要求：对页的访问模式应该是一样的。 注意哈希搜索只能是等值的，范围不行。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:7:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"异步IO 区别于同步IO。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:8:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"刷新邻近页 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:9:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"支持的索引 B+索引 聚集索引：实际的数据页在逻辑（双向链表）上按照这个索引来排序。叶子结点存放所有的数据。 辅助索引：叶子结点不包含行记录的所有数据，而是包含键值和书签，书签用于导航到表的具体位置。 哈希索引 全文检索（使用倒排索引实现） 倒排索引有一个持久化的表Auxiliary Table，存放着word。还有一个FTS Index Cache（全文检索索引缓存）用于提高全文检索的性能，内部为红黑树结构。 锁 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:10:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"lock和latch Innodb中latch可以分为mutex和rwlock。 lock面向事务，有检测和恢复死锁的机制。表现形式：行锁、表锁、意向锁。 latch面向线程，保护内存的数据结构，表现形式：读写锁、互斥量。且无检测和恢复死锁的机制。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:11:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"行级锁 Innodb实现了共享锁（S LOCK）和排他锁（X LOCK）。 同时也支持意向锁。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:12:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"一致性非锁定读 指Innodb在遇到某个行执行DELETE或者UPDATE操作时，读取操作不会去等待锁的释放，而是读取最近的一个快照数据。 这样极大地提高了数据库的并发性，这是默认的读取方式。 在READ COMMITED和REAPTABLE READ下，Innodb默认都是使用一致性非锁定读的方式。但是区别在于READ COMMITED下读的是最近的一次快照（违反了隔离性），而REAPTABLE READ下读的是事务开始时的快照。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:13:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"一致性锁定读 数据在修改时，不允许读操作。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:14:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"外键 外键主要用于引用完整性得约束检查。在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁。 对于外键值的插入或更新，首先需要查询父表中的记录，即SELECT 父表.但是对于父表的SELECT 操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题。因此这时使用的是 SELECT …. LOCK IN SHARE MODE 方式，即主动对父表加一个S锁，如果这时父表上已经这样加X锁，子表上的操作会被阻塞。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:15:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"聚簇索引 聚簇索引与非聚簇索引（也叫二级索引）–最清楚的一篇讲解 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:16:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"联合索引的技巧 联合索引的最左前缀匹配原则介绍_To be a great coder-CSDN博客_最左前缀匹配原则 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:17:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"幻读问题 20 | 幻读是什么，幻读有什么问题？-极客时间 间隙锁在可重复读隔离级别下才有效。 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。 这样，当你执行 select * from t where d=5 for update 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。 跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。 间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。 注意间隙锁之间可能会引起死锁。 MySQL 概述 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:18:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"逻辑架构 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:19:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"隔离级别 读未提交 所有事务可以看到未提交事务的执行结果。 读提交 大多数默认隔离级别是读提交，但是 MySQL 不是。读提交满足了隔离的早期定义：一个事务在开始时只能看见已经提交事务所做的改变。一个事务从开始到提交前，所做的任何数据改变是不可见的。 但是存在不可重复读。 可重复读 MySQL 的默认隔离级别，但是会产生幻读问题。 幻读指的是，当用户读取一个范围内的数据，会因为另外一个事务在该范围内插入新行，而导致重复读时会出现幻影行。InnoDB 使用 MVCC 多版本并发控制机制解决了这个问题。（这里应该还要搭配间隙锁） 可串行化 SERIALIZABLE 是最高的隔离级别，通过强制事务排序，使其不可能冲突。但是会导致大量的锁竞争。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:20:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"死锁的解决 InnoDB 中可以预知循环相关性，并立即返回错误。目前 InnoDB 处理死锁的方法是，回滚拥有最少排他行级锁的事务。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:21:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"AUTOCOMMIT 除非显式地开始一个事务，否则它把每一个查询视为一个单独事务。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:22:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"二阶段锁协议 InnnoDB 使用二阶段锁协议，一个事务在执行的任何过程中都可以得到锁，但是只有在执行 commit 或者 rollback 后才能释放。 显式使用锁定机制： SELECT … LOCK IN SHARE MODE SELECT … FOR UPDATE ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:23:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"MVCC 多版本并发控制 保证了同个事务的多个实例在运行时看到的都是一致的数据视图。 实现 MVCC 的方式有乐观并发控制、悲观并发控制。 InnoDB 通过给每行数据增加两个隐含值来实现 MVCC，行的创建时间和过期时间。当 可重复读时： 这样的话大多数读操作都不需要加锁。MVCC 仅存在于可重复读和读提交两个隔离级别。 数据引擎 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:24:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"MyISAM 不支持事务和行级锁 具有全文检索、压缩、空间函数。 对整张表进行加锁。 支持全文检索 延迟更新索引？ ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:25:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"InnoDB 处理大量短期事务 默认在可重复读的基础上加入间隙锁防止幻读。 聚簇索引提供快速的主键查找性能，辅助索引（非主键索引）也会包含主键列。 内部优化：可预测性的预读，支持在硬盘中 实现提取数据，可适应的哈希索引，自动在内存创建哈希索引，提供插入缓冲区。 支持事务和外键。 MVCC多版本 按主键聚合 所有索引包含主键列 自适应哈希 数据装载缓慢 阻塞的自动增长 索引 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:26:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"B+索引 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:27:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"B+索引的局限 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:28:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"哈希索引 只有 Memory 支持显式的哈希索引。 其具有很多局限性： 在 InnoDB 中，有自适应哈希索引，当其注意到一些 索引值被频繁访问时，会在 B+数 的顶端为这些值建立内存中的哈希索引。但是过程是全自动的。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:29:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"全文索引 是 MyISAM 的特殊索引，无最左适配的局限性。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:30:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"前缀索引 前缀索引可以节约索引的成本。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:31:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"聚簇索引（聚集索引） 聚簇索引是在 B+索引的基础上，叶子节点存放实际数据。 B+索引的末端存放的是聚簇索引的 key。 第二索引需要先索引找到聚簇索引的 key，然后再去聚簇索引搜索一次。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:32:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"覆盖索引 包含所有需要查询的数据列的索引称为覆盖索引。 ","date":"2021-03-30","objectID":"/mysql%E5%8E%9F%E7%90%86/:33:0","tags":["SQL"],"title":"MySQL 原理总结","uri":"/mysql%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"进程 ","date":"2021-02-08","objectID":"/linuxsystem/:0:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"MMU ","date":"2021-02-08","objectID":"/linuxsystem/:1:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"进程控制块PCB 进程控制块PCB的结构体形式：task_struct。 虚拟地址空间的信息描述为虚拟地址到物理地址的映射。MMU来维护。 umask掩码：保护文件权限。 ulimit -a 能查看linux资源上限 ","date":"2021-02-08","objectID":"/linuxsystem/:2:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"环境变量 以用户为单位设置环境变量。 PATH SHELL 当前SHELL TERM 当前终端类型 HOME LANG 类似于命令行参数。 extern char** eniron ","date":"2021-02-08","objectID":"/linuxsystem/:3:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"getenv 获取环境变量 ","date":"2021-02-08","objectID":"/linuxsystem/:3:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"setenv设置环境变量 ","date":"2021-02-08","objectID":"/linuxsystem/:3:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"unsetenv取消环境变量 ","date":"2021-02-08","objectID":"/linuxsystem/:3:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"进程控制 ","date":"2021-02-08","objectID":"/linuxsystem/:4:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"fork() 创建的是子进程。通过返回的pid来判断是否在子进程中。返回0时为子进程，父进程中返回子进程的pid。 ","date":"2021-02-08","objectID":"/linuxsystem/:4:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"getpid 获取 pid ","date":"2021-02-08","objectID":"/linuxsystem/:4:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"getppid 获取父亲 pid ","date":"2021-02-08","objectID":"/linuxsystem/:4:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"创建N个进程 #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int forkN(int n){ printf(\"I am the father %d\\n\", getpid()); for(int i = 0; i \u003c n; i++){ int pid = fork(); if(pid == -1){ perror(\"fork error!\"); exit(1); } else if(pid == 0){ printf(\"I am the %d child %u, my father is %u\\n\", i + 1, getpid(), getppid()); break; } } return 0; } ","date":"2021-02-08","objectID":"/linuxsystem/:4:4","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"进程共享 刚fork完时，父子进程中 全局变量、data、.text、栈、堆、环境变量、用户ID、目录、信号处理方式都是相同的。（0-3G地址相同） 不同在于进程id、fork返回值、父进程id、进程运行时间、定时器（一个进程有一个）、未决信号集。（PCB不一样） fork完之后，父子进程之间遵循读时共享，写时复制的原则，节省内存开销。 注意父子进程之间不能通过全局变量共享数据。（写时复制） 父子进程间共享的点： 文件描述符（多个进程对同一个文件操作） mmap建立的映射区（进程间通信） ","date":"2021-02-08","objectID":"/linuxsystem/:5:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"gdb调试多进程程序 set follow-fork-mod child set follow-fork-mod parent ","date":"2021-02-08","objectID":"/linuxsystem/:6:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"exec类函数 让程序执行一个进程（原进程的用户空间和代码完全被新程序替换）。 注意此时并不是创建一个新进程，而是原进程的用户空间和代码全部被替换。 重点execl和execlp。 execlp：（list path）加载一个进程，借助环境变量 execlp(\"ls\", \"ls\", \"-l\", \"-a\", NULL); //第二个参数相当于argv[0] 一般可能不使用 execl：通过路径+程序名来加载。 execl(\"/bin/ls\", \"ls\", \"-l\", \"-a\", NULL); execle:借助环境变量表 execv：不含argv[0]，但是参数先要包装成字符数组。 ","date":"2021-02-08","objectID":"/linuxsystem/:7:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"保存 ps 结果到 out #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/types.h\u003e #include \u003cfcntl.h\u003e #include \u003csys/stat.h\u003e int ps() { int fd = open(\"out\", O_WRONLY | O_CREAT | O_TRUNC, 0644); if(fd == -1){ perror(\"open file:\"); exit(1); } dup2(fd, STDOUT_FILENO); //把out文件的描述符复制到std::out int res = execlp(\"ps\", \"ps\", \"aux\", NULL); if(res == -1)perror(\"exec error:\"); exit(1); close(fd); return 0; } exec函数只在出错的时候返回-1。 ","date":"2021-02-08","objectID":"/linuxsystem/:8:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"回收子进程 ","date":"2021-02-08","objectID":"/linuxsystem/:9:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"孤儿进程 父进程先于子进程结束，子进程则为孤儿进程，子进程父进程变为init进程（孤儿院），父进程的pid变为1。 ","date":"2021-02-08","objectID":"/linuxsystem/:9:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"僵尸进程 进程终止了，但是父进程没有回收。子进程PCB残留在内核中，成为僵尸进程。 这里的父进程一直不停止，但是子进程的PCB一直不回收。 ","date":"2021-02-08","objectID":"/linuxsystem/:9:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"wait waitpid 解决僵尸函数 wait有三个功能 阻塞等待子进程退出。 回收子进程残留资源。 获取子进程结束状态。 一次wait只能回收一个进程，回收先结束的进程。 返回为pid时，回收成功，-1时，没有子进程。 wstatus为传出参数： kill -l可以查看信号结果。 waitpid函数更灵活一些，指定pid回收，且可以不阻塞。 pid为-1时，回收任意存在的子进程。 0 阻塞 WNOHANG 非阻塞，需要轮询。 总结： IPC进程间通信 常用方法： 管道（最简单） 信号（开销最小） 共享映射区（无血缘关系）（mmap） 本地套接字（最稳定） ","date":"2021-02-08","objectID":"/linuxsystem/:9:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"管道 pipe fifo（有名管道，非血缘关系间），pipe（匿名管道） 最简单的想法：通过文件实现进程间通信。抽象成为管道。 管道实际上为内核缓冲区，为伪文件。 一个管道有两个描述符，一个为读一个为写，默认为8k的缓冲区。 内部采用的是循环队列。 返回两个文件描述符，读和写。 ","date":"2021-02-08","objectID":"/linuxsystem/:10:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"简单的管道示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e int pipeTest(){ int fd[2]; //两个文件描述符 int ret = pipe(fd); if(ret == -1){ perror(\"pipe error:\"); exit(1); } pid_t pid = fork(); if(pid == -1){ perror(\"fork\"); exit(1); }else if(pid == 0){ //child read close(fd[1]); char buf[1024]; ret = read(fd[0], buf, sizeof(buf)); if(ret == 0){ printf(\"read done\\n\"); } write(STDOUT_FILENO, buf, ret); }else{ //father write close(fd[0]); sleep(1); char * str = \"hello pipe\\n\"; ret = write(fd[1], str, strlen(str)); } } ","date":"2021-02-08","objectID":"/linuxsystem/:10:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"mmap 共享内存 借助共享内存存放磁盘文件。这样可以通过指针访问磁盘文件。 addr：映射区的首地址 ，内核自动指定（直接传NULL) length：映射区大小（文件大小） prot：映射区的权限 PROT_READ PROT_WRITE PROT_READ | PROTWRITE flags：标志位参数 返回创建映射区的首地址。失败时返回MAP_FIALED。 fd：文件描述符 offset：映射文件的偏移（截取文件一部分） #include\u003cstdio.h\u003e #include\u003csys/mman.h\u003e #include\u003cstdlib.h\u003e #include\u003cfcntl.h\u003e #include\u003cstring.h\u003e #include\u003cunistd.h\u003e int mmapTest(){ char* p = NULL; int fd = open(\"text\", O_RDWR | O_CREAT, 0644); if(fd \u003c 0){ perror(\"open fail:\"); exit(1); } int len = 10; //size if( ftruncate(fd, len) == -1){ perror(\"ftruncate\"); //拓展文件 exit(1); } p = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(p == MAP_FAILED){ perror(\"MAP FAILED\"); exit(1); } strcpy(p, \"abc\"); //write to mmap int res = close(fd); if(res == -1){ perror(\"close fail\"); exit(1); } res = munmap(p, len); if(res == -1){ perror(\"unmap fail\"); exit(1); } return 0; } 注意事项： 不能创建一个大小为0的映射区（malloc可以） 注意munmap释放的必须是以前的首指针。 映射区的权限应小于等于实际文件。 映射区创建的时候需要读取文件权限。 offset需要4k的整数倍（一个页的大小）。 **** 文件描述符可以先关闭。 ","date":"2021-02-08","objectID":"/linuxsystem/:11:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"mmap 父子之间通信 参数应该为MAP_SHARED。 无血缘也相似，只要对同一个文件调用mmap就行。 读写两边都munmap()。 把映射区当数组看待。 ","date":"2021-02-08","objectID":"/linuxsystem/:11:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"mmap匿名映射 第三个参数位或MAP_ANONYMOUS(MAP_ANON)。此时文件描述符填-1。注意仅在Linux下有，类Unix下无。 类Unix下，应该打开/dev/zero文件来代替。 fifo和匿名映射的区别：fifo不可以重复读。 ","date":"2021-02-08","objectID":"/linuxsystem/:11:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"strace命令 strace binfile 可以查看程序调用的资源。 ","date":"2021-02-08","objectID":"/linuxsystem/:11:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"阶段性练习 Linux系统编程-实践练习 ","date":"2021-02-08","objectID":"/linuxsystem/:12:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"多文件拷贝 实现方法：文件分成多份，让多个进程去复制各个部分。 ","date":"2021-02-08","objectID":"/linuxsystem/:12:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"简单 shell ","date":"2021-02-08","objectID":"/linuxsystem/:12:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"本地聊天室功能 使用fcntl()函数把输入改造为非阻塞的。 Linux fcntl函数设置阻塞与非阻塞 信号 区别于信号量。 简单，不能携带大量信息，满足某个条件才会发送。 发送通过内核。程序收到信号后会停止下来处理信号（类似于时钟中断）。但是是通过软件来实现，也称为软中断。 软中断的延时非常大，但是对于用户来说不易察觉。CPU可以察觉。 四要素： 编号 名称 事件 默认处理动作 ","date":"2021-02-08","objectID":"/linuxsystem/:12:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"信号的传输过程 未决信号集代表了未处决的信号。 阻塞信号集（信号屏蔽字）代表了处于阻塞态的信号。 两者都处于PCB中。都是set。 当信号屏蔽字为1时，该位的信号将会保留下来，不能被处理。 信号的处理动作： 默认处理动作 忽略（丢弃） 捕捉（捕捉后调用用户处理函数（发送方）） 信号编号：kill -l man 7 signal 9和19号不允许被捕捉或阻塞。 ","date":"2021-02-08","objectID":"/linuxsystem/:13:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"信号的产生 产生方法： 按键 Ctrl + c ： 2）SIGINT（终止） Interrupt Ctrl + z： 20）SIGTSTOP（终端程序暂停） Stop Ctrl + \\： 3）SIGQUIT（退出） Quit 系统调用 软件 硬件异常 /0 (8)SIGFPE（浮点数例外） 非法访问内存 (11)SIGSEGV(段错误） 总线错误 （7）SIGBUS 命令调用 killl kill -19 pid 发送19信号 alarm setitimer， ","date":"2021-02-08","objectID":"/linuxsystem/:14:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"kill 函数 ","date":"2021-02-08","objectID":"/linuxsystem/:14:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"raise 与 abort 函数 ","date":"2021-02-08","objectID":"/linuxsystem/:14:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"alarm 函数 每个进程只有一个定时器。 指定需要的second后，内核会给当前进程发送（14）SIGALRM，默认行为为终止进程。 返回值为上一次alarm的剩余时间。 另外可以time ./app查看运行时间。 ","date":"2021-02-08","objectID":"/linuxsystem/:14:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"setitimer 可以取代alarm，精确到微秒，也可以周期性定时。 which函数代表如何定时（自然定时还是用户空间还是用户加内核）。 结构体看man page。 ","date":"2021-02-08","objectID":"/linuxsystem/:14:4","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"信号集操作 ","date":"2021-02-08","objectID":"/linuxsystem/:15:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"信号集设定 sigset_t 使用unsigned long构成的set（8字节）。 ","date":"2021-02-08","objectID":"/linuxsystem/:15:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sigprocmask 函数 把自定义的信号set导入到阻塞集。 ","date":"2021-02-08","objectID":"/linuxsystem/:15:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sigpending 函数 读取当前进程的未决信号集。 ","date":"2021-02-08","objectID":"/linuxsystem/:15:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"示例：打印未决信号集 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include\u003csignal.h\u003e #include \u003cstdlib.h\u003e void printsig(sigset_t *set){ for(int i = 1; i \u003c 32; i++){ printf(\"%d\", sigismember(set, i)); }printf(\"\\n\"); } int main() { sigset_t myset, oldset, pend; sigemptyset(\u0026myset); sigaddset(\u0026myset, SIGQUIT); int res = sigprocmask(SIG_BLOCK, \u0026myset, \u0026oldset); if(res == -1){ perror(\"sig error\"); exit(1); } sigpending(\u0026pend); printsig(\u0026pend); raise(SIGQUIT); sigpending(\u0026pend); while(1){ sleep(1); printsig(\u0026pend); } return 0; } ","date":"2021-02-08","objectID":"/linuxsystem/:15:4","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"信号的捕捉 ","date":"2021-02-08","objectID":"/linuxsystem/:16:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"signal 函数 使用signal函数可以捕捉到信号，调用自定义的处理函数。 ","date":"2021-02-08","objectID":"/linuxsystem/:16:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sigaction 函数 其中sigaction结构为 第二个参数不管。 sigset_t 定义handler运行期间的信号屏蔽字。 sa_flags 0时为默认。 ","date":"2021-02-08","objectID":"/linuxsystem/:16:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"捕捉原理 竞态条件 ","date":"2021-02-08","objectID":"/linuxsystem/:16:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pause函数： 可以造成进程主动挂起，等待信号唤醒。注意先要对信号进行捕捉。 注意这里返回的是-1。 使用sigaction和pause实现sleep： #include \u003cstdio.h\u003e #include \u003cerrno.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csignal.h\u003e void catchSignal(int signo){ ; } int mySleep(unsigned int seconds){ struct sigaction act, oldact; act.sa_handler = catchSignal; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; int ret = sigaction(SIGALRM, \u0026act, \u0026oldact); if(ret == -1){ perror(\"sigaction\"); exit(1); } alarm(seconds); ret = pause(); if(ret == -1 \u0026\u0026 errno == EINTR){ printf(\"signal caught!\\n\"); } ret = alarm(0); sigaction(SIGALRM, \u0026oldact, NULL); return ret; } int main(){ while(1)mySleep(1); } ","date":"2021-02-08","objectID":"/linuxsystem/:17:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"时序竞态 ","date":"2021-02-08","objectID":"/linuxsystem/:18:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"一个会出问题的例子 若CPU失去时间太长，pause将永远不会被唤醒。 ","date":"2021-02-08","objectID":"/linuxsystem/:18:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sigsuspend 函数 相当于带有信号屏蔽字的pause函数，可以解决以上问题。（原子操作） 流程： 注册SIGALRM处理函数 阻塞SIGALRM alarm→sigsuspend【解除阻塞SIGALRM→pause→继续阻塞SIGALRM】 解除SIGALRM处理函数 解除阻塞SIGALRM。 这样可以解决pause的时序问题。 ","date":"2021-02-08","objectID":"/linuxsystem/:18:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"全局变量异步IO问题 父子进程之间交替数数程序。运行一段时间后两者都永久等待。 #include \u003cstdio.h\u003e #include \u003csignal.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e int n = 0, flag = 0; //定义两个全局变量（注意了） void sys_err(char *str) { perror(str); exit(1); } void do_sig_child(int num) //子进程的用户处理函数 { printf(\"I am child %d\\t%d\\n\", getpid(), n); n += 2; flag = 1; //对全局变量的修改 } void do_sig_parent(int num) //父进程的用户处理函数 { printf(\"I am parent %d\\t%d\\n\", getpid(), n); n += 2; flag = 1; //对全局变量的修改 } int main(void) { pid_t pid; struct sigaction act; if ((pid = fork()) \u003c 0) sys_err(\"fork\"); else if (pid \u003e 0) { n = 1; //父进程从1开始数 sleep(1); //父进程睡眠1s确保在父进程向子进程发信号之前，子进程完成了对信号的注册 act.sa_handler = do_sig_parent; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; sigaction(SIGUSR2, \u0026act, NULL); //注册自己的信号捕捉函数，父进程使用SIGUSR2信号 do_sig_parent(0); //父进程先进行数数，从1开始 while(1) { /* wait for signal */; if (flag == 1) { //父进程数数完成 kill(pid, SIGUSR1); flag = 0; //标志已经给子进程发送完信号 } } } else if (pid == 0){ n = 2; //子进程从2开始数 act.sa_handler = do_sig_child; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; sigaction(SIGUSR1, \u0026act, NULL); while(1) { /* wait for signal */; if (flag == 1) { kill(getppid(), SIGUSR2); flag = 0; } } } return 0; } 问题在于flag的修改，若某一进程修改不及时，另一进程已经发送了信号，那么就会导致原进程在执行完信号后才修改flag为0，那么两者就会死锁。 这里的全局是原程序和内核回调函数的并行。 改进方法：直接不使用flag，把信号发送放到回调函数里面。 ","date":"2021-02-08","objectID":"/linuxsystem/:18:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"可重入函数 显然这个是不可重入的函数，主要原因是使用了全局变量。 注意事项： 可重入函数不能有全局变量以及static变量。不能有malloc和free。 信号捕捉函数应该设计为可重入函数。 信号处理程序可以调用的可重入函数可以参阅man 7 signal. 没有在以上列表中的函数大多是不可重入的。 静态数据结构 调用了malloc和free 是标准的IO函数 ","date":"2021-02-08","objectID":"/linuxsystem/:18:4","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"SIGCHLD回收子进程 对父进程发送信号。可以利用SIGCHLD信号回收子进程。 为了避免信号的覆盖，需要在回收函数里面使用while来处理所有的子进程。 这里使用if时，会使得一些进程没有回收。 ","date":"2021-02-08","objectID":"/linuxsystem/:19:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"信号传参 ","date":"2021-02-08","objectID":"/linuxsystem/:20:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"发送参数 sigqueue函数对应kill函数，可以在发送信号的同时携带参数。 但是注意传地址时，每个进程的虚拟地址空间独立，把虚拟地址传到另一进程没有实际意义。 ","date":"2021-02-08","objectID":"/linuxsystem/:20:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"接收参数 ","date":"2021-02-08","objectID":"/linuxsystem/:20:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"中断系统调用 系统调用： 慢速系统调用：可能会使得本进程永久阻塞。如pause、wait、waitpid、read 其他系统调用。 对于慢速系统调用，被信号打断后，按需求希望恢复操作或者跳过操作（read和pause）。 发送信号时，sa_flags参数可以设置是否被信号中断后重启。也可以设置该信号不自动被屏蔽。 终端、进程组、会话、守护进程 ","date":"2021-02-08","objectID":"/linuxsystem/:21:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"终端 是所有输入输出设备的总称。所有的进程都有一个父进程init。每个进程都可以通过/dev/tty访问它的控制终端。 ","date":"2021-02-08","objectID":"/linuxsystem/:22:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"启动流程 线路规程像一个过滤器，对某些字符进行特殊处理。如ctrl+c会被线路规程截获，而不是读到read中。 ","date":"2021-02-08","objectID":"/linuxsystem/:22:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"ttyname函数 借助ttyname函数可以看到不同终端对应的设备文件名。 ","date":"2021-02-08","objectID":"/linuxsystem/:22:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"网络终端 ","date":"2021-02-08","objectID":"/linuxsystem/:22:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"进程组 ps ajx 作业就是进程组，代表一个或多个进程的集合。 当父进程创建子进程，默认子进程与父进程为同一个组，组ID为父进程的ID（组长）。 ","date":"2021-02-08","objectID":"/linuxsystem/:23:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"getpgrp 获取进程组ID ","date":"2021-02-08","objectID":"/linuxsystem/:23:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"getpgid 获取指定进程的进程组id ","date":"2021-02-08","objectID":"/linuxsystem/:23:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"setpgid 设定指定进程的进程组id 注意非root进程只能改变自己的子进程。 ","date":"2021-02-08","objectID":"/linuxsystem/:23:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"会话 一组进程组可以编号成一个会话。 ","date":"2021-02-08","objectID":"/linuxsystem/:24:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"创建会话 ","date":"2021-02-08","objectID":"/linuxsystem/:24:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"getsid 查看会话id ","date":"2021-02-08","objectID":"/linuxsystem/:24:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"setsid 设置会话id 会话可以做守护进程。 ","date":"2021-02-08","objectID":"/linuxsystem/:24:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"守护进程 Daemon进程，是Linux中的后台服务进程，通常独立于控制终端且周期性执行某种任务或等待某个事件。通常以d结尾（httpd、sshd）。且不受用户登录退出的影响。 最关键的一步：使用setsid创建一个新的session，并成为session leader。 ","date":"2021-02-08","objectID":"/linuxsystem/:25:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"创建方式 创建子进程，父进程退出 fork 在子进程中创建新会话 setsid 设置当前目录为根目录（防止被卸载） chdir 重设文件权限掩码 umask函数（防止继承的文件创建屏蔽字拒绝某些权限） 关闭文件描述符（不要浪费系统资源） 通常重定向到/dev/null dup2() 开始守护核心工作 守护进程退出模型（很少用到） #include\u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cstdlib.h\u003e int main() { pid_t pid, spid; pid = fork(); if(pid == 0) //child { spid = setsid(); int ret = chdir(\"/home/hongwei\"); if(ret == -1){ perror(\"chdir\"); exit(1); } umask(0002); close(STDIN_FILENO); int fd = open(\"/dev/null\", O_RDWR); if(fd \u003c 0){ perror(\"open\"); exit(1); } dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); while(1){ sleep(1); } } else if(pid \u003e 0){ return 0; } return 0; } 在bashrc文件中加入运行命令，则可以保证每次开机自动启动。 线程 ","date":"2021-02-08","objectID":"/linuxsystem/:25:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"概念 Linux下仍是轻量级的进程，差别不大。 进程：独立的地址空间、PCB 线程：也有PCB，但是没有独立的地址空间（共享）。 进程（独居），线程（合租） 线程是最小的执行单位，进程是最小的资源分配的单位。 ","date":"2021-02-08","objectID":"/linuxsystem/:26:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"Linux线程实现原理 线程是由进程发展而来，底层实现类似。都是用clone()，也有PCB。 从内核的角度来看，进程和线程都一样，有不同的PCB。但是PCB中指向内存的三级页表对于线程来说是相同的。 线程可以看成是寄存器和栈的集合。 内核中的栈用于记录临时的寄存器值，便于恢复。 LWP号（线程号，区分于线程id） ps -Lf pid。 线程号：CPU分配运行时间的依据。 线程id：进程内部区分线程的方法。 ","date":"2021-02-08","objectID":"/linuxsystem/:26:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"线程共享资源 文件描述符表 每种信号的处理方式（尽量不要线程和信号一起使用） 当前工作目录 用户ID和组ID 内存地址空间 .text .data .bss heap 共享库 ","date":"2021-02-08","objectID":"/linuxsystem/:26:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"非共享资源 线程id 处理器现场和栈指针（内核栈） 独立的栈空间（用户栈） errno变量 信号屏蔽字 调度优先级 ","date":"2021-02-08","objectID":"/linuxsystem/:26:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"优缺点 优点： 提高程序并发性 开销小 数据通信、共享数据方便 缺点： 库函数不稳定（pthread） 调试困难，gdb不支持 对信号支持不好 在Linux下，由于实现方法导致进程线程的差别不大。 ","date":"2021-02-08","objectID":"/linuxsystem/:26:4","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"控制原语 ","date":"2021-02-08","objectID":"/linuxsystem/:27:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_self 对应getpid（）获取线程id。 ","date":"2021-02-08","objectID":"/linuxsystem/:27:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_create 对应fork（） 传出线程id，传入属性（可以是NULL），主控函数，函数参数。 注意返回值为错误编号（非-1）。 存疑：注意传参时最好为值传递，内存地址情况可能会发生改变。 ","date":"2021-02-08","objectID":"/linuxsystem/:27:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_exit 将单个线程退出。如果是主控线程，则可以使得子线程继续运行而非退出。exit函数会直接把进程结束。return作用为返回值到调用者处。 ","date":"2021-02-08","objectID":"/linuxsystem/:27:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_join 对应waitpid（）。回收线程。 返回的retval若传指针则需要malloc。也可以在main中malloc。 线程的回收不需要一定是主控线程。 ","date":"2021-02-08","objectID":"/linuxsystem/:27:4","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_detach 实现线程分离，对线程在状态上实现分离，其退出状态不被获取，且自己释放，不会成为僵尸线程。 ","date":"2021-02-08","objectID":"/linuxsystem/:27:5","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_cancel 对应kill，直接杀死某线程。但是需要线程到达一定的检查点。 使用man 7 pthreads 查看所有取消点。如read pause open creat close… 也可以自定义取消点 pthread_testcancel()。 ","date":"2021-02-08","objectID":"/linuxsystem/:27:6","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"原语对比 getpid : pthread_self fork: pthread_create wait: pthread_join(tid, void**) exit(): pthread_exit(void*) kill(): pthread_cancel(); 到达取消点 pthread_detach 自动清理pcb ","date":"2021-02-08","objectID":"/linuxsystem/:27:7","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"线程属性 pthread_attr_init/destroy 函数初始化和销毁这个属性结构体。 调整栈的大小使得能建立更多的线程。 注意此时是在堆上创建线程。 ","date":"2021-02-08","objectID":"/linuxsystem/:28:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"NPTL 线程库版本 getconf GNU_LIBPTHREAD_VERSION ","date":"2021-02-08","objectID":"/linuxsystem/:29:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"注意事项 避免僵尸进程 join detach 避免使用fork（） 避免使用信号 线程同步 ","date":"2021-02-08","objectID":"/linuxsystem/:30:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"概念 线程的同步是指协同，互相配合，线程按照一定的先后次序运行。 一个线程发出某一功能调用时，直到这个功能调用结束为止，其他线程不调用这个功能。 数据发生时间错误条件： 数据共享。 竞争。 多个对象没有合理的同步机制。 ","date":"2021-02-08","objectID":"/linuxsystem/:31:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"互斥量 mutex 结构体pthread_mutex_t(可以看做一个整数）。 ","date":"2021-02-08","objectID":"/linuxsystem/:32:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_mutex_init（destory） restrict关键字： 如何理解C语言关键字restrict？ restrict 是为了告诉编译器额外信息（两个指针不指向同一数据），从而生成更优化的机器码。 ","date":"2021-02-08","objectID":"/linuxsystem/:32:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_mutex_lock 用阻塞等待方法加锁。 ","date":"2021-02-08","objectID":"/linuxsystem/:32:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_mutex_trylock 不阻塞方法加锁。（轮询） ","date":"2021-02-08","objectID":"/linuxsystem/:32:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_mutex_unlock 解锁。 锁的粒度应该越小越好。 ","date":"2021-02-08","objectID":"/linuxsystem/:32:4","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"死锁 1、线程尝试对锁加两次锁。 2、多个线程互相等待。 解决方法： 使用pthread_mutex_trylock，若失败则放弃已有的锁，日后再加锁。 ","date":"2021-02-08","objectID":"/linuxsystem/:32:5","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"读写锁 读写锁是一把锁。具备三种状态 读锁 写锁 不加锁 写独占，读共享，写锁优先度高。（写者优先）pthread_rwlock_t ","date":"2021-02-08","objectID":"/linuxsystem/:33:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"条件变量 条件变量不是锁，但是可以造成线程阻塞，通常与互斥锁搭配使用。 pthread_cond_t ","date":"2021-02-08","objectID":"/linuxsystem/:34:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_cond_wait pthread_cond_wait函数有三个功能： 阻塞等待一个条件变量满足。 释放已经掌握的互斥锁。 以上两个为原子操作 当被唤醒，解除阻塞并重新申请获取互斥锁。 使用pthread_cond_signal唤醒一个线程。pthead_cond_boardcast唤醒所有线程。 ","date":"2021-02-08","objectID":"/linuxsystem/:34:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"pthread_cond_timedwait 在指定时间内等待。 这里的abstime为timespec结构体： abstime是绝对时间(相对于unix诞生时间): time_t cur = time(NULL); struct timespec t; t.tv_sec = cur + 1; pthread_cond_timedwait(\u0026cond, \u0026mutex, \u0026t); ","date":"2021-02-08","objectID":"/linuxsystem/:34:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"使用条件变量解决生产者消费者模型 条件变量代表是否缓冲区有产品。 条件变量的优点在于减少了竞争，消费者之间在生产时不再需要竞争互斥锁。 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e #include\u003cpthread.h\u003e pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t has_product = PTHREAD_COND_INITIALIZER; struct msg{ int num; struct msg *next; }; struct msg *head = NULL, *mp = NULL, *mc = NULL; void* producer(void* arg){ while(1){ mp = malloc(sizeof(struct msg)); mp -\u003e num = rand() % 400 + 1; printf(\"=\u003eproduced %d\\n\", mp -\u003e num); pthread_mutex_lock(\u0026mutex); mp -\u003e next = head; head = mp; pthread_mutex_unlock(\u0026mutex); int ret = pthread_cond_signal(\u0026has_product); if(ret != 0){ printf(\"signal failed\\n\"); pthread_exit(NULL); } sleep(rand() % 3); } return NULL; } void* consumer(void* arg){ while(1){ pthread_mutex_lock(\u0026mutex); while(head == NULL){ pthread_cond_wait(\u0026has_product, \u0026mutex); } mc = head; head = mc -\u003e next; pthread_mutex_unlock(\u0026mutex); printf(\"=\u003econsumed: %d\\n\", mc-\u003enum); free(mc); mc = NULL; sleep(rand() % 2); } return NULL; } int main() { pthread_t ptid, ctid; int ret = pthread_create(\u0026ptid, NULL, producer, NULL); if(ret != 0){ printf(\"create error\\n\"); exit(1); } ret = pthread_create(\u0026ctid, NULL, consumer, NULL); if(ret != 0){ printf(\"create error\\n\"); exit(1); } pthread_join(ptid, NULL); pthread_join(ctid, NULL); } ","date":"2021-02-08","objectID":"/linuxsystem/:34:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"信号量（也可以应用于进程间同步） 进化版的互斥锁。留意信号量的函数都是用errno来返回错误信息。 sem_t 信号量结构体。 ","date":"2021-02-08","objectID":"/linuxsystem/:35:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sem_init 初始化信号量。 第二个参数代表是否能在进程间共享，当非0，表示可以共享。 ","date":"2021-02-08","objectID":"/linuxsystem/:35:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sem_destroy 销毁信号。 ","date":"2021-02-08","objectID":"/linuxsystem/:35:2","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sem_wait 信号量减一 若信号量小于0，线程阻塞。 ","date":"2021-02-08","objectID":"/linuxsystem/:35:3","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sem_trywait ","date":"2021-02-08","objectID":"/linuxsystem/:35:4","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sem_timedwait ","date":"2021-02-08","objectID":"/linuxsystem/:35:5","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"sem_post 信号量加一，若信号量小于等于0，同时唤醒信号量上的进程。 ","date":"2021-02-08","objectID":"/linuxsystem/:35:6","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"生产者消费者 void *producer(void *arg) { int i = 0; while (1) { sem_wait(\u0026blank_number); //生产者将空格子数--,为0则阻塞等待 queue[i] = rand() % 1000 + 1; //生产一个产品 printf(\"----Produce---%d\\n\", queue[i]); sem_post(\u0026product_number); //将产品数++ i = (i+1) % NUM; //借助下标实现环形 //sleep(rand()%3); } } void *consumer(void *arg) { int i = 0; while (1) { sem_wait(\u0026product_number); //消费者将产品数--,为0则阻塞等待 printf(\"-Consume---%d\\n\", queue[i]); queue[i] = 0; //消费一个产品 sem_post(\u0026blank_number); //消费掉以后,将空格子数++ i = (i+1) % NUM; //sleep(rand()%3); } } 为什么不需要互斥锁？ ","date":"2021-02-08","objectID":"/linuxsystem/:35:7","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"进程间同步 ","date":"2021-02-08","objectID":"/linuxsystem/:36:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"互斥量 进程中的互斥量需要修改mutex的属性。 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cpthread.h\u003e #include \u003csys/mman.h\u003e #include \u003csys/wait.h\u003e struct mt { int num; pthread_mutex_t mutex; pthread_mutexattr_t mutexattr; }; int main(void) { int i; struct mt *mm; pid_t pid; /* int fd = open(\"mt_test\", O_CREAT | O_RDWR, 0777); ftruncate(fd, sizeof(*mm)); mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); close(fd); unlink(\"mt_test\"); */ mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0); memset(mm, 0, sizeof(*mm)); pthread_mutexattr_init(\u0026mm-\u003emutexattr); //初始化mutex属性对象 pthread_mutexattr_setpshared(\u0026mm-\u003emutexattr, PTHREAD_PROCESS_SHARED); //修改属性为进程间共享 pthread_mutex_init(\u0026mm-\u003emutex, \u0026mm-\u003emutexattr); //初始化一把mutex琐 pid = fork(); if (pid == 0) { for (i = 0; i \u003c 10; i++) { pthread_mutex_lock(\u0026mm-\u003emutex); (mm-\u003enum)++; pthread_mutex_unlock(\u0026mm-\u003emutex); printf(\"-child----------num++ %d\\n\", mm-\u003enum); } } else if (pid \u003e 0) { for ( i = 0; i \u003c 10; i++) { // sleep(1); pthread_mutex_lock(\u0026mm-\u003emutex); mm-\u003enum += 2; pthread_mutex_unlock(\u0026mm-\u003emutex); printf(\"-------parent---num+=2 %d\\n\", mm-\u003enum); } wait(NULL); } pthread_mutexattr_destroy(\u0026mm-\u003emutexattr); //销毁mutex属性对象 pthread_mutex_destroy(\u0026mm-\u003emutex); //销毁mutex munmap(mm,sizeof(*mm)); //释放映射区 return 0; } ","date":"2021-02-08","objectID":"/linuxsystem/:36:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"文件锁 ","date":"2021-02-08","objectID":"/linuxsystem/:37:0","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"fcntl函数 修改已经打开文件的属性，修改阻塞和非阻塞。 可以借助其来设置文件锁。 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e void sys_err(char *str) { perror(str); exit(1); } int main(int argc, char *argv[]) { int fd; struct flock f_lock; if (argc \u003c 2) { printf(\"./a.out filename\\n\"); exit(1); } if ((fd = open(argv[1], O_RDWR)) \u003c 0) sys_err(\"open\"); f_lock.l_type = F_WRLCK; /*选用写琐*/ // f_lock.l_type = F_RDLCK; /*选用读琐*/ f_lock.l_whence = SEEK_SET; f_lock.l_start = 0; f_lock.l_len = 0; /* 0表示整个文件加锁 */ fcntl(fd, F_SETLKW, \u0026f_lock); printf(\"get flock\\n\"); sleep(10); f_lock.l_type = F_UNLCK; fcntl(fd, F_SETLKW, \u0026f_lock); printf(\"un flock\\n\"); close(fd); return 0; } 多线程间不可以用文件锁，因为文件描述符共享。 ","date":"2021-02-08","objectID":"/linuxsystem/:37:1","tags":["Coding","Linux"],"title":"Linux 系统编程","uri":"/linuxsystem/"},{"categories":null,"content":"作为补充，开始了解一些简单的设计模式。 应该掌握的 单例 工厂 代理 策略模式 模板方法 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:0:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"简单工厂模式 考虑用一个单独的类去创建实例。 #include\u003ciostream\u003e #define DBG_MACRO_NO_WARNING #include\u003cdbg.h\u003e using namespace std; template\u003ctypename T\u003e class Operation{ public: Operation(){} Operation(const T\u0026 n1,const T\u0026 n2): N1(n1), N2(n2){} virtual T getResult() const{ return 0; } void setA(const T\u0026 val){N1 = val;} void setB(const T\u0026 val){N2 = val;} protected: T N1; T N2; }; template\u003ctypename T\u003e class OperationPlus: public Operation\u003cT\u003e{ public: OperationPlus(const T n1, const T n2): Operation\u003cT\u003e(n1, n2){}; T getResult() const override{ return this-\u003eN1 + this-\u003eN2; } }; template\u003ctypename T\u003e class Factory{ public: Operation\u003cT\u003e* createOperation(const T\u0026 a, const T\u0026 b, string oper){ if(oper == \"+\"){ op = new OperationPlus\u003cT\u003e(a, b); } return op; } virtual ~Factory(){ delete op; } private: Operation\u003cT\u003e *op; }; int main(){ Factory\u003cint\u003e factory; auto oper = factory.createOperation(1, 2, \"+\"); dbg(oper-\u003egetResult()); } ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"策略模式 定义了算法家族，分别封装起来，可以相互替换。使得算法的变化不影响客户。 把某个实现方法抽象为接口，使用组合而不是继承。 想修改具体某个算法时，不需要其用户改变。 一言以蔽之，使用组合把算法做成接口。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"单一职责原则 就一个类而言，应该仅有一个引起它变化的原因。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"开放-封闭原则 软件实体应该可以扩展，但是不可修改。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"依赖倒转原则 抽象不应该依赖细节，细节应该依赖于抽象。针对接口编程。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:5:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"里氏代换原则 子类必须能够替换掉他们的父类。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:6:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"装饰模式 动态地给一个对象添加一些额外的职责。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:7:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"代理模式 为其他对象提供一种代理以控制对这个对象的访问。Proxy 类里面有一个 RealSubject，真实访问类。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:8:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"工厂方法模式 定义一个用于创建对象的接口，让子类决定实例化哪个类。即将一个类的实例化延迟到子类。 简单工厂实际上就是工厂方法去掉 Creator。简单工厂只有一种生产方式，而工厂方法可以实现多种工厂以应对多种生产方式。又或者可以传递参数给工厂，实现工厂的动态变化生产。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:9:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"模板方法模式 定义一个操作中算法的骨架，将一些步骤延迟到子类。模板方法使得子类能不改变算法的结构也能重定义算法的某些步骤。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:10:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"原型模式 用原型实例创建指定对象的种类，并通过拷贝创建新的对象。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:11:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"抽象工厂方法 实际上抽象工厂就是多个工厂方法模式，区别就是在于抽象工厂会产生多种类的实例。而工厂方法仅仅是一种类。在抽象工厂中，任何一个工厂实例都有能力生产各种实例。 抽象工厂提供了一个创建实例的接口，用于创建相关或依赖对象的家族，但是不需要指定具体的类。 ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:12:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"单例模式 保证一个类仅有一个实例，且提供一个访问它的全局访问点。 class singleton { private: singleton() {} static singleton *p; public: static singleton *instance(); }; singleton *singleton::p = nullptr; singleton* singleton::instance() { if (p == nullptr) p = new singleton(); return p; } 线程安全的版本（定义时即初始化） class singleton { private: singleton() {} static singleton *p; public: static singleton *instance(); }; singleton *singleton::p = new singleton(); singleton* singleton::instance() { return p; } ","date":"2021-02-01","objectID":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:13:0","tags":["CS","designPattern"],"title":"一些简单的设计模式","uri":"/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"模板知识 template\u003ctypename T\u003e class complex { public: //... private: T re, im; }; complex\u003cint\u003e c; complex\u003cchar\u003e a; 编译器会对模板函数进行实参推导。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:1:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"Specialization 特化 对某种特定的类型，可以给一个特定的函数。 template\u003c\u003e class complex\u003cint\u003e{}; //... STL 源代码中 __STL_TEMPLATE_NULL //equal to template\u003c\u003e //特化 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:1:1","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"Partial Specialization 偏特化 类似于偏微分。第一种： template\u003cclass T, class Alloc = alloc\u003e class vector { //... } //泛化 template\u003cclass Alloc\u003e class vector\u003cbool, Alloc\u003e //对第一个模板做了偏特化 { //... } 对多个模板中的某个模板进行特化，为第一种偏特化。 第二种偏特化：范围的偏特化。 上面例子对 T 为指针时做了偏特化，常量指针又做了偏特化。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:1:2","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"分配器 allocators 分配器扮演的是幕后英雄的角色。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:2:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"operator new 和 malloc new 的底部其实是调用了 malloc。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:2:1","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"allocator VC6，GCC和 BC5 的 allocator 只是用 new 和 delete 的重载完成了 allocate（）和 deallocate（），没有其他特殊设计。 可以自己尝试去调用： int *p = allocator\u003cint\u003e().allocate(512, (int*)0); allocator\u003cint\u003e().deallocate(p, 512); 这里要求使用者知道当初申请了多少单位的内存，而容器调用时则不会出现这种问题。 所有的容器用的都是这种分配器。若无数元素都是使用new ，将会消耗大量的格外空间，造成浪费。 GCC 中说明，虽然做出了这个分配器，但是自己的容器都不使用它。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:2:2","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"alloc GCC 2.9.1实际上默认的 alloc： 主要诉求是，减少 malloc 的次数。这样可以减少 cookies，还有内存对齐带来的浪费。 容器的大小按 8 的倍数来分配。第一个链表负责 8byte，第二个负责 16byte，第三个负责 24byte。。。当链表的内存用完后，再借用其他链表的内存，连接起来。这样减少了 cookies。 但是 GCC4.9使用的又变回了没有特殊设计的 allocator。alloc 的名称也被变为__pool_alloc。 容器 container 和 迭代器 iterator 红黑树是 set、map 的底层。vector 支撑了 heap，heap 支撑了 priority_queue。deque 支撑了 stack 和 queue。unordered_ 类的底层都是 hashtable。 这里的关系是组合而非继承。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:2:3","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"list 链表 list_node 是平时的节点，list 包含一个 list_node 的指针。一个 list_node 除了数据，还有两个指针。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:3:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"__list_iterator iterator：希望它模拟指针的动作，因而会取到 list_node 中的 next 中去。 template\u003cclass T, class Ref, class Ptr\u003e class __list_iterator{ //必须的五个 typedef typedef T value_type; typedef Ptr pointer; typedef Ref reference; typedef __list_node\u003cT\u003e* link_type; typedef ptrdiff_t difference_type; link_type node; //操作符重载... }; ++的实现： 注意这里跟整数一样，i++++或 (i++)++都是非法操作。所以返回是否为引用，也很讲究。 *号：取得 data的引用；→号：取得本身操作对象数据地址。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:3:1","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"GCC4.9的改进 iterator 只保留了一个模板参数，更好。节点本身的 prev 和 next 不再是 void*，更好。 但是也变得更复杂。新版的 list 多了一个指向最后空白节点的指针，大小变为 8。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:3:2","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"iterator 迭代器的特征 迭代器回答算法关于数据的一些性质，从而启示算法如何去执行。如算法 rotate： 上面反映的三种回答： iterator_category 迭代器的分类：如是否可以+=3，是否可以两向移动。。。 value_type 数据的类型 difference_type 两个数据之间距离的类型。 另外还有两种： reference_type pointer_type 后面两种从来没有被使用过。 但若单纯的指针作为迭代器时，就需要萃取（Traits）了。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:4:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"萃取 有能力把普通的指针的特性提取出来。利用偏特化可以写出萃取机： c++针对各种类型都定义有萃取机。这里加上 typename 告诉编译器这里指的是类型名，而不是模板。例： iterator_traits\u003cIterator\u003e::iterator_category;; ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:4:1","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"vector vector 包含三个迭代器（私有）：start，finish，end_of_storage。 装满了之后会两倍成长。 增长的过程: 注意在 c++11 中右值引用的方法如何降低了增长的成本? C++ 11\u002614（2.0）新标准（侯捷） GCC4.9中的 vector： 又变得复杂了。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:5:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"array array 必须指定大小 array\u003cint, 10\u003e myarray; 疑问：template\u003ctypename *Tp, std::size_*t _Nm\u003e 代表模板里面可以放参数？ 是的。 array 其实只是对数组做了一层包装，加上 iterator。 疑问：为什么这里的 begin 和 end 函数要加上 noexcept？ C++11 带来的新特性 （3）– 关键字noexcept ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:6:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"deque，queue 和stack deque 其实是分段连续，对外表现形式为连续。底层的一个 vector 中放的每个元素都是一个指针，分别指向一段连续 buffer。多段的 buffer 形成了连续的队列。当 某一段 buffer 用完，vector 添加一个指针在后端，申请一段新的 buffer。 vector 扩张时，原有的指针会被复制到新 vector 的中央。 deque 的迭代器是一个 class，有四个指针。其中first 指向当前缓冲区的头部，last 指向当前缓冲区的尾部，node 指向 vector。vector 这里起到了 buffer 之间的连接功能。 当 cur 走到了某个缓冲区的尾部，迭代器会自动回到 vector 中找到下一个缓冲区。 start 和 finish 迭代器如图所示，一切都按照 iterator 的接口来定义。 新版不再允许自定义 buffersize。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:7:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"deque::insert() 注意 deque 是支持随机访问的，并不是单纯的双端队列。 deque 需要判断元素是向前移动还是向后移动更好。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:7:1","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"deque 中 iterator的操作符重载 简单的计算可以算出任意两个 iterator 间的距离。注意 buffersize 都是相同的。 注意一般都是用后置运算符调用前置运算符。 +可以利用+=来完成。先判断要不要跨越缓冲区，如果需要，则需计算出真正缓冲区的位置，切换到正确的缓冲区后再切换到元素的位置。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:7:2","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"queue 和 stack queue 和 stack都是以 deque 作为底层实现。 可以称 queue 和 stack 为 adapter。注意 queue 和 stack 都不提供iterator。一般标准容器才有 iterator。 为什么以 deque 作为底部呢？ 实际上 两者可以选择 list和 deque 作为底部。 且stack 可以用 vector 做底层结构，queue 不行。因为 vector 并没有 pop_front()函数。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:7:3","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"rb-tree 关联式容器的地步都是红黑树和 散列表 。 特性： 平衡二叉搜索树 提供遍历 iterators，能获得排序的状态。 begin为最左边的节点，end为最右边的节点，中序遍历。 map的排序是按照key来排序，而data是可以改变的。因此这里的元素值应该是开放修改的。 实现： 红黑树只有三个data：node_count, header, key_compare。 分别对应的是红黑树的节点数量，红黑树的头，key比较的方法。注意红黑树的header为空的，为了实现上的方便。 keyofvalue模板告诉红黑树如何从value中取出key。 key_compare的为functionlike object，大小为1。 _Rb_tree\u003cint, int, _Identity\u003cint\u003e, less\u003cint\u003e\u003e tree; cout \u003c\u003c tree.empty() \u003c\u003c endl; GNU4.9的版本同样变得非常复杂。实际上这是OO里面Handel的做法。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:8:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"set 与 multiset 区别：元素能否重复。都是以红黑树为底层，元素会自动按照key排序。而对于set来说，key和value是同一样东西。 提供遍历和iterators。无法通过迭代器来赋值。 这里GNU的identity指的是key即value。而在VC6下为_Kfn。 当取set的iterator时，取到的其实是rb_tree的const_iterator。 所以set也是adapter。 set和multiset的区别仅仅是insert函数调用的不同。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:9:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"map 和 multimap map与set区别在于map的daata与key并不相同。 map应该做到无法改变key，但是可以改变data。 留意这里的Key被const所修饰，因此不能被修改。这里的keyofvalue则是selectfirst。这也是显而易见的。 而对于multimap而言，这样的操作是非法的。 mul_map[1] = 2; //非法 对于map的[]重载，当key不存在时，会使用默认值创建这个元素。 除此之外，安插key的位置是由lower_bound函数实现的。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:10:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"hashtable 有一个约定俗成的经验规则：当元素个数达到数组长度，rehashing。数组的长度变为两倍。 设计特点： Hashfunction 可以建立一个元素到一个数值的映射。 ExtractKey是一个可以从传入元素的得到key的一个function。 EqualKey 一个比较key是否相等的函数。 node就是平常的单向链表。 iterator 的设计就是两个指针。 hashtable的使用： unordered類的容器底層都是紅黑樹。 算法 Algorithm 从语言层面来说，只有算法是函数模板，其他都是类模板。 算法借iterator来获取机制来执行。 各个容器的iterator tag： ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:11:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"iterator_category 对算法的影响 可以看到distance()函数针对不同的迭代器做了不一样的特化。 iterators的继承关系，会使得子类的继承迭代器调用到父类的算法。 copy()对迭代器的优化： 这里的type萃取机回答这个type是否具有拷贝赋值特性。默认的构造函数是不重要的（trivial）。 注意算法中的函数参数仅仅只是模板，不一定一定要指定的iterator。仅仅是暗示需要什么迭代器。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:12:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"算法实现剖析 accumulate 累计算法 注意C中的数组也要遵循前闭后开区间规则。 for_each: replace: count: 关联式容器自带count函数。 关于这里返回值为什么要加typename： C++ typename 用法 - youxin - 博客园 find 也类似于count。 sort： 这里myvec.rbegin() myvec.rend() 是反向迭代器。还有cbegin()和cend()为常量迭代器。 binary_search: lower_bound() 不改变排序的情况下能插入target的最低点。 upper_bound() 不改变排序能插入target的最高点。 二分查找借助了lower_bound() 函数。注意这里返回的只是bool。 仿函数 functors STL中最简单的部件。最容易自己写的部分。皆是function like class。 二元： 二元函数继承binary_function\u003cT1, T2, Result\u003e 后即可使用。 一元： 注意这些函数非标准库一部分。类似的，继承自unary_function\u003cArg,Result\u003e 。不继承的话也可以运行，但是不继承会带来问题。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:13:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"functors的可适配条件 有了三个typedef，才能回答Function Adapter的问题： 适配器 Adapter 是设计模式之中的一个。存在很多Adapter。 有容器适配器、迭代器适配器和仿函数适配器，都是使用组合的方式而非继承。 如stack和queue都是deque的容器适配器，它们内含一个deque。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:14:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"函数适配器 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:15:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"bind2nd(c++11中被弃用） 没有not1函数时，这里计算有多少个元素小于40. bind2nd起到了把第二个参数绑定为40的作用。 实际上创建了一个对象，这个对象的数据成员value记录第二个参数的值，op记录函数对象，（）重载时直接调用把value传进去用作第二个参数。 注意这里bind2nd函数（左上角）返回的是一个临时对象，而非函数调用的结果。 辅助函数起到了自动推导Operation的作用： template\u003cclass Operation, class T\u003e inline binder2nd\u003cOperation\u003e bind2nd(const Operation\u0026 op, const T \u0026x) { typedef typename Operation::second_argument_type arg2_type; return binder2nd\u003cOperation\u003e(op, arg2_type(x));//temp object } typedef 类型 arg2_type是为了确保第二个参数不错误。如输入double时，会直接转换为int。这里其实作为function的可适配条件（adaptable）。 而本身bind2nd继承自unary_function，作为一元函数。 新型的适配器bind: 在新版本中被bind淘汰。bind的实现机制比较复杂。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:15:1","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"not1 not1函数在这里是否定的意思。 虽然只是一个取否操作，但是为了adaptable的性质，需要做出一些工作。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:15:2","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"bind 新型适配器 使用方法： #include\u003cfunctional\u003e using namespace std::placeholders; int main(){ auto myfun = bind(fun, 100); myfun(); auto myfun1 = bind(fun2, _1, 10);//占位符 for(int i = 0; i \u003c 3; i++)myfun1(i); } 另外bind\u003cint\u003e(args...)代表返回类型为int。 绑定member function： //member function 带有隐式参数*this auto fun = bind(\u0026myPair::fun1, pair1, _1); fun(arg1); //pair1 为object //or auto fun = bind(\u0026myPair::fun1, _1, _2); fun(pair1, arg1); 绑定member data也类似。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:15:3","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"迭代器适配器 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:16:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"reverse iterator rbegin() 和 rend() 可以看做从尾往头的一个迭代器。 操作符重载也要做相应的变化。 留意对逆向取值其实就是对正向退一位取值。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:16:1","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"inserter insert会自己创建空间，插入到容器中。 list\u003cint\u003e l{1,2,3,4,5}, r{6,7,8,9,10}; copy(l.begin(), l.end(), inserter(r, r.begin())); 实现的方式为把=操作符重载： ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:16:2","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"未知分类的iterator ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:17:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"ostream_iterator 把元素copy到ostream这个容器里面，相当于直接输出。这里的逗号作为分隔符。同样是使用操作符重载来实现。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:17:1","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"istream_iterator 与ostream_iterator雷同，注意的是构造时就会开始读入参数。 一切设计都符合逻辑。 STL之外 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:17:2","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"万用的Hash Function 可以设计为类或者单纯的函数。最先想到的是直接把数据成员的hash值加起来: 但是碰撞会非常多。TR1： 使用variadic templates，结合seed和combine函数。 或者以偏特化的形式自己扩充STL： ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:18:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"tuple 实际上是一个镶嵌自己的类，以组合的形式保留数据。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:19:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"type traits https://zh.cppreference.com/w/cpp/header/type_traits 回答对于某个类型而言，构造函数等等是否重要。 C++11中添加了更多的回答,且自动完成。 是否为多态： 实现is_void： 利用特化去掉const和volatile，最后特化到void，如果是void就返回true。 is_integral也类似： ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:20:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"cout cout是一个对象。 它继承自ostream。对一系列类型做了操作符重载。 ","date":"2021-01-23","objectID":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/:21:0","tags":["Coding","STL","C++"],"title":"STL-源码剖析（侯捷）","uri":"/stl-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%BE%AF%E6%8D%B7/"},{"categories":null,"content":"刷题地址 题库 - 力扣 (LeetCode) ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:0:1","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"题解地址 CyC2018/CS-Notes ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:0:2","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"3.数组中重复的数字 把值为 i 的数值交换到 index 为 i 的位置上。（即实现了一个 hash） class Solution { public: void swap(int\u0026 a, int \u0026b){ int t = a; a = b; b = t; } int findRepeatNumber(vector\u003cint\u003e\u0026 nums) { for(int i = 0; i \u003c nums.size(); i++){ if(nums[i] == nums[nums[i]] \u0026\u0026 i != nums[i]){ //注意 i 不能等于 nums[i] return nums[i]; } else{ swap(nums[i], nums[nums[i]]); if(nums[i] == nums[nums[i]] \u0026\u0026 i != nums[i]){ return nums[i]; } } } return -1; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:1:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"4.二维数组中的查找 从右上角开始查找，小的数在左，大的数在下。 class Solution { public: bool findNumberIn2DArray(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { if(matrix.size() == 0)return false; //注意边界 int i = 0, j = matrix[0].size() - 1; while(i != matrix.size() \u0026\u0026 j != -1){ cout \u003c\u003c matrix[i][j] \u003c\u003c endl; if(matrix[i][j] == target){ return true; } else if(matrix[i][j] \u003e target){ j--; } else{ i++; } } return false; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:2:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"5.替换空格 把空格替换成%20： 先将数组补充到需要的长度，然后从后到前，使用快慢指针。 class Solution { public: string replaceSpace(string s) { string space = \"%20\"; int count = 0; for(auto c : s){ if(c == ' '){ count++; } } for(int i = 0; i \u003c count * 2; i++){ s += \" \"; } int i = s.size() - count*2 - 1; int j = s.size() - 1; for(; i \u003e= 0; i--){ if(s[i] == ' '){ j -= 3; s[j + 1] = '%', s[j + 2] = '2', s[j + 3] = '0'; } else{ s[j--] = s[i]; } } return s; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:3:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"6.从尾到头打印链表 方法一：递归 方法二：使用栈。两种方法的复杂度应该是一样的。 方法三：将链表倒置（头插法），再遍历。方法四：最后将结果转置。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:4:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"7.重建二叉树 前序遍历：先遍历目前节点。 中序遍历：先遍历左子树，再遍历目前节点，最后遍历右子树。 后序遍历：先遍历左子树，再遍历右子树，最后遍历当前节点。 注意到 preorder 的第一个元素一定是 root，可以把 inorder 切割成两半，依次递归生成左子树和右子树。 class Solution { public: TreeNode* buildTree(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder) { if(preorder.size() == 0 || inorder.size() == 0)return nullptr; int rootval = -1; int inorderRoot = -1; for(rootval = 0; rootval \u003c preorder.size(); rootval++){ auto it = find(inorder.begin(), inorder.end(), preorder[rootval]); if(it != inorder.end()){ inorderRoot = distance(inorder.begin(), it); break; } } if(rootval == -1)return nullptr; TreeNode * node = new TreeNode(preorder[rootval]); vector\u003cint\u003e nextPreorder(preorder.begin() + rootval + 1, preorder.end()); vector\u003cint\u003e left(inorder.begin(), inorder.begin() + inorderRoot), right(inorder.begin() + inorderRoot + 1, inorder.end()); node -\u003e left = buildTree(nextPreorder, left); node -\u003e right = buildTree(nextPreorder, right); return node; } }; 这里还可以用for来做 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:5:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"9.两个栈实现队列 核心思想是，一个栈作为in的缓存区，一个栈作为out的缓存区。每次pop的时候，把in的元素全部push到out中。 注意在转移元素后还需要验证out是否为空。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:6:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"10.1.斐波那契数列 可以用 dp 思想： class Solution { public: int fib(int n) { int back = 0, front = 1, ans; if(n == 0)return 0; if(n == 1)return 1; for(int i = 0; i \u003c= n - 1; i++){ ans = (back + front) % 1000000007; front = back; back = ans; } return ans; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:7:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"10.2.青蛙跳台阶 经典 dp 问题，首先是备忘录解法： class Solution { public: int numWays(int n) { if(n == 0)return 1; vector\u003cint\u003e dp(n + 1, 0); dp[0] = 1; for(int i = 0; i \u003c= n; i++){ dp[i] = dp[i] % 1000000007; if(i \u003c n)dp[i + 1] += dp[i]; if(i \u003c n - 1)dp[i + 2] += dp[i]; } return dp[n] % 1000000007; } }; 其次是降维优化： class Solution { public: int numWays(int n) { if(n == 0)return 1; int front = 1, mid = 0, back = 0; for(int i = 0; i \u003c n; i++){ front = front % 1000000007; if(i \u003c n)mid += front; if(i \u003c n - 1)back += front; front = mid; mid = back; back = 0; } return front % 1000000007; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:8:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"11.旋转数组的最小数字 每次二分之后都会有一侧含有最小的数字。每次选择那一侧，右边界即为最小的数字。此外当检测到前指针的值等于后指针的值时，切换到顺序查找。 class Solution { public: int minArray(vector\u003cint\u003e\u0026 nums) { if (nums.size() == 0) return 0; int l = 0, h = nums.size() - 1; while (l \u003c h) { int m = l + (h - l) / 2; if (nums[l] == nums[m] \u0026\u0026 nums[m] == nums[h]) return minNumber(nums, l, h); else if (nums[m] \u003c= nums[h]) h = m; else l = m + 1; } return nums[l]; } int minNumber(vector\u003cint\u003e\u0026 nums, int l, int h) { for (int i = l; i \u003c h; i++) if (nums[i] \u003e nums[i + 1]) return nums[i + 1]; return nums[l]; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:9:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"12.矩阵中的路径 回溯法直接开写： class Solution { public: bool exist(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, string word) { for(int i = 0; i \u003c board.size(); i++){ for(int j = 0; j \u003c board[0].size(); j++){ if(backtrack(board, word, i, j, 0)){ return true; } } } return false; } private: bool backtrack(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, const string \u0026 word, int row, int col, int step){ char now = board[row][col]; if(now != word[step]){ return false; } else if(step + 1 == word.size()){ return true; }//注意这里的终止条件判断 // cout \u003c\u003c row \u003c\u003c \" \" \u003c\u003c col \u003c\u003c \" \" \u003c\u003c board[row][col] \u003c\u003c endl; board[row][col] = '\\0'; if(row != 0 \u0026\u0026 board[row - 1][col] != '\\0'){ if(backtrack(board, word, row - 1, col, step + 1)){ return true; } } if(row != board.size() - 1 \u0026\u0026 board[row + 1][col] != '\\0'){ if(backtrack(board, word, row + 1, col, step + 1)){ return true; } } if(col != 0 \u0026\u0026 board[row][col - 1] != '\\0'){ if(backtrack(board, word, row, col - 1, step + 1)){ return true; } } if(col != board[0].size() - 1 \u0026\u0026 board[row][col + 1] != '\\0'){ if(backtrack(board, word, row, col + 1, step + 1)){ return true; } } board[row][col] = now; return false; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:10:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"13.机器人的运动范围 回溯法解决： class Solution { public: int movingCount(int m, int n, int k) { int count = 0; vector\u003cbool\u003e visted(m * n, false); backtrack(k, 0, 0, m, n, visted); for(int i = 0; i \u003c m*n; i++){ if(visted[i])count++; } return count; } private: bool check(int i, int j,int sum){ while(i != 0){ sum -= (i%10); i /= 10; } while(j != 0){ sum -= (j%10); j /= 10; } return (sum \u003e= 0); } void backtrack(int k, int i, int j, int m, int n, vector\u003cbool\u003e\u0026 visted){ if(visted[i*n + j])return; if(check(i, j, k)){ // cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j \u003c\u003c endl; visted[i*n + j] = true; } else{ return; } if(i != 0){ backtrack(k, i - 1, j, m, n, visted); } if(j != 0){ backtrack(k, i, j - 1, m, n, visted); } if(i != m - 1){ backtrack(k, i + 1, j, m, n, visted); } if(j != n - 1){ backtrack(k, i, j + 1, m, n, visted); } } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:11:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"14.剪绳子 解法一：动态规划 解法二：当长度大于4时，优先剪长度为3的片段。 int cuttingRope(int n) { return n \u003c= 3? n - 1 : pow(3, n / 3) * 4 / (4 - n % 3); } big number版： class Solution { public: //n \u003e= 5 2*(n-2) \u003e n 3*(n-3) \u003e n 且3*(n-3) \u003e= 2*(n-2) //n = 4 2 * 2 \u003e 1 * 3 //2和3不能再分了 分了就变小了 且3优于2 int cuttingRope(int n) { if (n \u003c= 3) return n-1; long rs = 1; while (n \u003e 4) { //3最优 rs *= 3; rs %= 1000000007; n -= 3; } //循环结束 n只剩下1, 2 ,3,4 //1不能再分 //2，3再分会标小 //4 可以分成1 * 3 2 * 2,所以还是4最优 //所以 剩下的1 2 3 4 都不能再分了 return (rs * n) % 1000000007; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:12:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"15. 二进制中1的个数 与运算 或运算 异或运算：两者不相同即为真 左移运算 右移运算 最简单的思路：当n不为0的时候，不断右移。 这里uint32_t代表这个是正数。 class Solution { public: int hammingWeight(uint32_t n) { int count = 0; while(n != 0){ count += (n%2); n = n \u003e\u003e 1; } return count; } }; 注意这里需要知道右移的效率比除以2的效率要高。且以上解法无法处理负数的case（右移会自动把第一位变成1）。 此外利用技巧n=n\u0026(n-1) 可以直接减少1的位数。 class Solution { public: int hammingWeight(uint32_t n) { int count = 0; while(n){ n = n\u0026(n-1); count++; } return count; } }; 负数的解决方法： 用一个flag变量作为掩码，避免死循环的问题。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:13:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"16.数值的整数次方 虽然不需要考虑大数问题，但是需要考虑负数以及溢出问题。 此外利用了快速幂方法，降低复杂度。 $$x^n=\\left{\\begin{aligned}\u0026x^{\\frac{n}{2}}x^{\\frac n2} \\ (n \\ even)\\\u0026x^{\\frac{n-1}{2}}x^{\\frac{n-1}{2}}x\\ (n\\ odd)\\end{aligned}\\right.$$ class Solution { public: double myPow(double x, int n) { double result = 1.0; if(n == 0){ return 1.0; } if(n == 1){ return x; } long nLong = n; bool isNegative = (n \u003c 0); if(isNegative){ nLong = -nLong; } if(nLong % 2 == 0){ double sqrtResult = myPow(x, nLong / 2); result = sqrtResult * sqrtResult; } else{ double sqrtResult = myPow(x, (nLong - 1) / 2); result = sqrtResult * sqrtResult * x; } return isNegative? 1.0/result: result; } }; 另外有位运算方法，如 class Solution { public: double myPow(double x, int n) { double result = 1.0; if(n == 0){ return 1.0; } if(n == 1){ return x; } long nLong = n; bool isNegative = (n \u003c 0); if(isNegative){ nLong = -nLong; } while(nLong != 0){ if(nLong \u0026 1){ result *= x; } x *= x; nLong = nLong \u003e\u003e 1; } return isNegative? 1.0/result: result; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:14:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"17.打印从1到n位最大的数 此题需要考虑大数问题。可以考虑为0-9的全排列，用回溯法直接解决。 或者在字符串上实现加法。 class Solution { public: vector\u003cint\u003e res; vector\u003cint\u003e printNumbers(int n) { if (n \u003c= 0) return res; string number(n, '0'); for (int i = 0; i \u003c= 9; i++) //从高位到低位进行全排列 { number[0] = i + '0';//首字符赋初值 permutationNumbers(number, n, 1);//设置下一位 } return res; } //对数字全排列 void permutationNumbers(string\u0026 number, int length, int index) { if (index == length) {//递归边界 saveNumber(number);//存储结果 return; } else { for (int i = 0; i \u003c= 9; i++) { number[index] = '0' + i;//设置第index位的字符 permutationNumbers(number, length, index + 1); } } } //存储结果 //只能存储前导非0的排列 void saveNumber(string number) { bool isBegin0 = true; string tempStr = \"\"; string::iterator it = number.begin(); while (it != number.end()) { if (isBegin0 \u0026\u0026 *it != '0') isBegin0 = false; if (!isBegin0) { tempStr += *it; } it++; } //从高位到低位全排列，要注意首字符为0时，tempStr为空，不能执行stoi if (tempStr != \"\") { int tempNum = stoi(tempStr); res.push_back(tempNum); } } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:15:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"18.1 在 O(1) 时间内删除链表节点 假设已经知道要删除链表节点的地址，可以直接将该节点下一节点的值复制过来，再连接下下节点，最后删除下一个节点即可。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:16:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"特性 当要删除的为最后一个节点，则需要换回顺序查找。 当删除节点为头节点的时候，需要返回nullptr 当节点数据非常大的时候，复制会非常久。 平均时间复杂度为O(1)。 需要编辑head的时候需要ListNode** 这里传入的是指针的指针，但是由于→具有传递的性质，所以下面的行为与传入指针一样。同时又可以通过*p 编辑表头。 void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted) { if(!pListHead || !pToBeDeleted) return; // 要删除的结点不是尾结点 if(pToBeDeleted-\u003em_pNext != nullptr) { ListNode* pNext = pToBeDeleted-\u003em_pNext; pToBeDeleted-\u003em_nValue = pNext-\u003em_nValue; pToBeDeleted-\u003em_pNext = pNext-\u003em_pNext; delete pNext; pNext = nullptr; } // 链表只有一个结点，删除头结点（也是尾结点） else if(*pListHead == pToBeDeleted) { delete pToBeDeleted; pToBeDeleted = nullptr; *pListHead = nullptr; } // 链表中有多个结点，删除尾结点 else { ListNode* pNode = *pListHead; while(pNode-\u003em_pNext != pToBeDeleted) { pNode = pNode-\u003em_pNext; } pNode-\u003em_pNext = nullptr; delete pToBeDeleted; pToBeDeleted = nullptr; } } ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:16:1","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"19.正则表达式匹配 动态规划方法： dp[i][j]代表前i个字符串是否能被前j个pattern匹配。 当pattern中为字母时： $$dp[i][j]=dp[i-1][j-1]\\cap s[i]==p[j]$$ 当pattern中为.时： $$dp[i][j]=dp[i-1][j-1]$$ 以上两种情况应该写入一个match函数中。 当pattern 中为* ： 若*没有被用上（*前面的字符匹配0次） $$dp[i][j]=dp[i][j-2]$$ 否则看最后一个字符是否匹配 $$dp[i][j]=dp[i-1][j]\\cup match(s[i],p[j-1])$$ Base: $$dp[0][0]=true$$ 注意这里是要(**m+1) X (n+1)**的dp数组的。 class Solution { public: bool isMatch(string s, string p) const { int m = s.size(), n = p.size(); vector\u003cvector\u003cbool\u003e\u003e dp(m+1, vector\u003cbool\u003e(n+1, false)); dp[0][0] = true; for(int i = 0; i \u003c= m; i++){ for(int j = 1; j \u003c= n; j++){ // cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j \u003c\u003c endl; if(p[j-1] != '*'){ dp[i][j] = (i\u003e0) \u0026\u0026 dp[i-1][j-1] \u0026\u0026 matches(s[i - 1], p[j - 1]); } else{ if(i != 0 \u0026\u0026 j \u003e 1 \u0026\u0026 matches(s[i-1], p[j-1-1])){ dp[i][j] = ((j\u003e0) \u0026\u0026 dp[i][j-1]) //singal a || (i\u003e0\u0026\u0026dp[i-1][j]); //multiply a } if(j\u003e=2)dp[i][j] = dp[i][j] || dp[i][j-2]; //zero a } // cout \u003c\u003c \"dp\" \u003c\u003c i \u003c\u003c j \u003c\u003c \" \" \u003c\u003c dp[i][j] \u003c\u003c endl; } } return dp[m][n]; } private: bool matches(char si, char pi) const{ return (pi == '.') || (pi == si); } }; 简化版代码 public boolean match(char[] str, char[] pattern) { int m = str.length, n = pattern.length; boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int i = 1; i \u003c= n; i++) if (pattern[i - 1] == '*') dp[0][i] = dp[0][i - 2]; for (int i = 1; i \u003c= m; i++) for (int j = 1; j \u003c= n; j++) if (str[i - 1] == pattern[j - 1] || pattern[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1]; else if (pattern[j - 1] == '*') if (pattern[j - 2] == str[i - 1] || pattern[j - 2] == '.') { dp[i][j] |= dp[i][j - 1]; // a* counts as single a dp[i][j] |= dp[i - 1][j]; // a* counts as multiple a dp[i][j] |= dp[i][j - 2]; // a* counts as empty } else dp[i][j] = dp[i][j - 2]; // a* only counts as empty return dp[m][n]; } ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:17:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"20.表示数值的字符串 有限状态自动机： 翻译成代码 class Solution { public: enum State { STATE_INITIAL, STATE_INT_SIGN, STATE_INTEGER, STATE_POINT, STATE_POINT_WITHOUT_INT, STATE_FRACTION, STATE_EXP, STATE_EXP_SIGN, STATE_EXP_NUMBER, STATE_END, }; enum CharType { CHAR_NUMBER, CHAR_EXP, CHAR_POINT, CHAR_SIGN, CHAR_SPACE, CHAR_ILLEGAL, }; CharType toCharType(char ch) { if (ch \u003e= '0' \u0026\u0026 ch \u003c= '9') { return CHAR_NUMBER; } else if (ch == 'e' || ch == 'E') { return CHAR_EXP; } else if (ch == '.') { return CHAR_POINT; } else if (ch == '+' || ch == '-') { return CHAR_SIGN; } else if (ch == ' ') { return CHAR_SPACE; } else { return CHAR_ILLEGAL; } } bool isNumber(string s) { unordered_map\u003cState, unordered_map\u003cCharType, State\u003e\u003e transfer{ { STATE_INITIAL, { {CHAR_SPACE, STATE_INITIAL}, {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT}, {CHAR_SIGN, STATE_INT_SIGN}, } }, { STATE_INT_SIGN, { {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT}, } }, { STATE_INTEGER, { {CHAR_NUMBER, STATE_INTEGER}, {CHAR_EXP, STATE_EXP}, {CHAR_POINT, STATE_POINT}, {CHAR_SPACE, STATE_END}, } }, { STATE_POINT, { {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP}, {CHAR_SPACE, STATE_END}, } }, { STATE_POINT_WITHOUT_INT, { {CHAR_NUMBER, STATE_FRACTION}, } }, { STATE_FRACTION, { {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP}, {CHAR_SPACE, STATE_END}, } }, { STATE_EXP, { {CHAR_NUMBER, STATE_EXP_NUMBER}, {CHAR_SIGN, STATE_EXP_SIGN}, } }, { STATE_EXP_SIGN, { {CHAR_NUMBER, STATE_EXP_NUMBER}, } }, { STATE_EXP_NUMBER, { {CHAR_NUMBER, STATE_EXP_NUMBER}, {CHAR_SPACE, STATE_END}, } }, { STATE_END, { {CHAR_SPACE, STATE_END}, } } }; int len = s.length(); State st = STATE_INITIAL; for (int i = 0; i \u003c len; i++) { CharType typ = toCharType(s[i]); if (transfer[st].find(typ) == transfer[st].end()) { return false; } else { st = transfer[st][typ]; } } return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:18:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"21.调整数组顺序使得奇数在偶数前面 双指针： class Solution { public: vector\u003cint\u003e exchange(vector\u003cint\u003e\u0026 nums) { int left = 0, right = nums.size() - 1; while(left \u003c right){ if(nums[left] % 2 == 1){ left++; } else if(nums[right] % 2 == 0){ right--; } else{ swap(nums[left], nums[right]); left++; right--; } } return nums; } private: void swap(int \u0026 a, int \u0026 b){ int t = a; a = b; b = t; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:19:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"22.链表中倒数第 k 个节点 快慢指针，注意边界 class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { if(head == nullptr)return head; ListNode* back = head; for(int i = 0; i \u003c k; i++){ if(back -\u003e next == nullptr){ return head; } back = back -\u003e next; } while(back != nullptr){ back = back -\u003e next; head = head -\u003e next; } return head; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:20:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"23. 链表中环的入口结点 双指针法。fast 指针是 slow 指针速度的两倍。假设环入口节点为 y1，相遇所在节点为 z1。 第一次相遇，此时 fast 走过$x+Ny+(N-1)z$。slow 走过$x+y$。同时又有$2(x+y)=x+Ny+(N-1)z$.解得$x=(N-2)y+(N-1)z=(N-2)C+z$. 这个等式左边是从起点x1 到环入口节点 y1 的长度，而右边是在圆环中走过 (N-2) 圈，再从相遇点 z1 再走过长度为 z 的长度。此时我们可以发现如果让两个指针同时从起点 x1 和相遇点 z1 开始，每次只走过一个距离，那么最后他们会在环入口节点相遇。 即 slow 走过: $x+y+x=x+y+(N-2)y+(N-1)z=x+(N-1)C$ fast走过： $x$ 两者相遇于入口。 class Solution { public: ListNode* EntryNodeOfLoop(ListNode* pHead) { if(pHead == nullptr || pHead -\u003e next == nullptr){ return nullptr; } ListNode* slow = pHead, * fast = pHead; while(fast -\u003e next != nullptr \u0026\u0026 fast -\u003e next -\u003e next != nullptr){ fast = fast -\u003e next -\u003e next; slow = slow -\u003e next; if(slow == fast){ break; } } fast = pHead; while(fast != slow){ fast = fast -\u003e next; slow = slow -\u003e next; } return fast; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:21:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"24.反转链表 三个指针：head mid back class Solution { public: ListNode* reverseList(ListNode* head) { if(head == nullptr || head-\u003enext == nullptr)return head; ListNode* mid = head -\u003e next, *back = mid -\u003e next; head -\u003e next = nullptr; while(back != nullptr){ mid -\u003e next = head; head = mid; mid = back; back = back -\u003e next; } mid -\u003e next = head; return mid; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:22:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"25.合并两个排序链表 双指针迭代： class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* head = new ListNode(1); ListNode* ret = head; while (l1 != NULL \u0026\u0026 l2 != NULL) { if (l1-\u003eval \u003c l2-\u003eval) { head-\u003enext = l1; l1 = l1-\u003enext; } else { head-\u003enext = l2; l2 = l2-\u003enext; } head = head-\u003enext; } head-\u003enext = l1 == NULL ? l2 : l1; return ret-\u003enext; } }; 递归： class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (l1 == NULL) { return l2; } if (l2 == NULL) { return l1; } if (l1-\u003eval \u003c= l2-\u003eval) { l1-\u003enext = mergeTwoLists(l1-\u003enext, l2); return l1; } l2-\u003enext = mergeTwoLists(l1, l2-\u003enext); return l2; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:23:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"26.树的子结构 判断一棵树是否为另一棵树的一部分。 使用两个树的遍历函数解决： class Solution { public: bool isSubStructure(TreeNode* A, TreeNode* B) const { if(B == nullptr || A == nullptr)return false; return locateAt(A, B) || isSubStructure(A-\u003eleft, B) || isSubStructure(A-\u003eright, B); } private: bool locateAt(TreeNode* A, TreeNode* B) const { if(B == nullptr)return true; if(A == nullptr)return false; if(A-\u003eval != B-\u003eval){ return false; } return locateAt(A-\u003eleft, B-\u003eleft) \u0026\u0026 locateAt(A-\u003eright, B-\u003eright); } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:24:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"27.反转二叉树 遍历一次树搞定： class Solution { public: TreeNode* mirrorTree(TreeNode* root) { if(root == nullptr)return nullptr; TreeNode* temp = root -\u003e left; root -\u003e left = root -\u003e right; root -\u003e right = temp; mirrorTree(root -\u003e left); mirrorTree(root -\u003e right); return root; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:25:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"28.对称二叉树 比较左树的左子树是否与右树的右子树相同。。。 class Solution { public: bool solve(TreeNode* r1, TreeNode* r2){ if (r1 == nullptr \u0026\u0026 r2 == nullptr) return true; else if(r1 == nullptr || r2 == nullptr) return false; if (r1-\u003eval != r2 -\u003e val) return false; return solve(r1-\u003eleft, r2-\u003eright) \u0026\u0026 solve(r1-\u003eright, r2-\u003eleft); } bool isSymmetric(TreeNode* root) { if(root == nullptr)return true; return solve(root -\u003e left, root -\u003e right); } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:26:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"29.顺时针打印矩阵 设置四个变量，直接打印: class Solution { public: vector\u003cint\u003e spiralOrder(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { vector\u003cint\u003e res; if(matrix.size() == 0 || matrix[0].size() == 0)return res; int lt = 0, rt = matrix[0].size() - 1; int lb = matrix.size() - 1; while(2 * lt \u003c min(matrix.size(), matrix[0].size())){ //!!! // cout \u003c\u003c lt \u003c\u003c \" \" \u003c\u003c lb \u003c\u003c \" \" \u003c\u003c rt \u003c\u003c endl; for(int i = lt; i \u003c= rt; ++i)res.push_back(matrix[lt][i]); if(lt \u003e= lb)return res; //!!! for(int i = lt + 1; i \u003c= lb; ++i)res.push_back(matrix[i][rt]); if(lt \u003e= rt)return res; //!!! for(int i = rt - 1; i \u003e= lt; --i)res.push_back(matrix[lb][i]); for(int i = lb - 1; i \u003e lt; --i)res.push_back(matrix[i][lt]); lt++; rt--; lb--; } return res; } }; 这里第一第二次的打印都是打满的。 或者可以用 visted[m][n]构造一个螺旋走的递归函数。（类似于回溯法），这种方法的空间复杂度为 $O(mn)$。 一个更好的做法： class Solution { public: vector\u003cint\u003e spiralOrder(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { vector\u003cint\u003e res; int m = matrix.size(); if(m == 0) return res; int n = matrix[0].size(); for(int k = 0; 2 * k \u003c min(m, n); ++k) { for(int j = k; j \u003c n - k; ++j) { res.push_back(matrix[k][j]); } for(int i = k + 1; i \u003c m - k; ++i) { res.push_back(matrix[i][n - k - 1]); } if(2 * k + 1 \u003e= min(m, n))return res; for(int j = n - k - 2; j \u003e= k; --j) { res.push_back(matrix[m - k - 1][j]); } for(int i = m - k - 2; i \u003e k; --i) { res.push_back(matrix[i][k]); } } return res; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:27:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"30.实现 O（1）的 minStack 使用两个 stack，一个 记录数据，一个记录最小值。 注意记录最小值的条件为小于等于。 class MinStack { public: MinStack() { } void push(int x) { if(sortedData.empty() || x \u003c= sortedData.top()){ sortedData.push(x); } data.push(x); } void pop() { if(data.empty()){ return; } else{ if(sortedData.top() == top()){ sortedData.pop(); } data.pop(); } } int top() { if(!data.empty())return data.top(); else return -1; } int min() { if(!data.empty()) return sortedData.top(); else return -1; } private: stack\u003cint\u003e data; stack\u003cint\u003e sortedData; }; 用户错用调用函数的情况可以用 assert 来进行防御性编程。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:28:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"31.栈的压入，弹出序列 使用一个栈，每 push 一个元素，都去根据 popped 序列尝试 pop 所有的元素。最后检测是否完成了整个 popped 队列。 class Solution { public: bool validateStackSequences(vector\u003cint\u003e\u0026 pushed, vector\u003cint\u003e\u0026 popped) { if(popped.size() == 0)return true; if(pushed.size() == 0)return false; stack\u003cint\u003e s; int pPopped = 0; for(int i = 0; i \u003c pushed.size(); i++){ s.push(pushed[i]); //注意防止 pPopped 越界 while(!s.empty() \u0026\u0026 pPopped \u003c popped.size() \u0026\u0026s.top() == popped[pPopped]){ s.pop(); pPopped++; } } return pPopped == popped.size(); } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:29:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"32.树的层序遍历 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:30:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"普通遍历 使用队列： class Solution { public: vector\u003cint\u003e levelOrder(TreeNode* root) { vector\u003cint\u003e result; if(root == nullptr)return result; queue\u003cTreeNode*\u003e s; s.push(root); while(!s.empty()){ root = s.front(); s.pop(); if(root != nullptr){ result.push_back(root-\u003eval); s.push(root-\u003eleft); s.push(root-\u003eright); } } return result; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:30:1","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"分层遍历： 另外记录一个变量 deep class Solution { public: void traverse(TreeNode* root, vector\u003cvector\u003cint\u003e\u003e\u0026 result, int deep){ if(root == nullptr)return; // cout \u003c\u003c result.size() \u003c\u003c deep \u003c\u003c endl; if (result.size() \u003c= deep) result.push_back(vector\u003cint\u003e(0)); if(root -\u003e left != nullptr)result[deep].push_back(root -\u003e left -\u003e val); if(root -\u003e right != nullptr)result[deep].push_back(root -\u003e right -\u003e val); traverse(root -\u003e left, result, deep+1); traverse(root -\u003e right, result, deep+1); } vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { vector\u003cvector\u003cint\u003e\u003e result; if (root == nullptr) return result; result.push_back(vector\u003cint\u003e(0)); result[0].push_back(root -\u003e val); traverse(root, result, 1); result.pop_back(); return result; } }; 非递归可以用 queue 来实现，使用 dfs 时，queue 的长度代表了层数。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:30:2","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"之字形： 可以对偶数层直接倒序。 或者使用 bfs+queue，此时 queue 的大小代表每层元素的数量。 class Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { if(root == NULL) return {}; vector\u003cvector\u003cint\u003e \u003e res; queue\u003cTreeNode*\u003e q; q.push(root); bool odd = true; while(!q.empty()) { int size = q.size(); //队列大小表示当前层数的元素个数 vector\u003cint\u003e level(size); //存放每一层的元素值 for(int i = 0; i \u003c size; ++i) //逐个对该层元素进行处理 { TreeNode *temp = q.front(); q.pop(); int index = odd? i : (size-1-i); //如果为奇数行则从后向前加入元素 level[index] = temp-\u003eval; if(temp-\u003eleft) q.push(temp-\u003eleft); if(temp-\u003eright) q.push(temp-\u003eright); } odd = !odd; res.push_back(level); //将当层元素加入res中 } return res; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:30:3","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"33.检查是否为有效的二叉搜索树后序遍历序列 最后一个元素一定 为 root，递归写法： class Solution { public: bool verifyPostorder(vector\u003cint\u003e\u0026 postorder) { return solve(postorder, 0, postorder.size()); } private: bool solve(const vector\u003cint\u003e\u0026 postorder, int start, int end) { if(end - start \u003c= 1)return true; int rootVal = postorder[end - 1]; // cout \u003c\u003c rootVal \u003c\u003c endl; int rightHead = end - 1; for(int i = start;i \u003c= end - 2; i++){ if(postorder[i] \u003e rootVal){ rightHead = i; break; } } for(int i = rightHead + 1;i \u003c= end - 2; i++){ if(postorder[i] \u003c rootVal)return false; } return solve(postorder, start, rightHead) \u0026\u0026 solve(postorder, rightHead, end - 1); } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:31:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"34. 二叉树中和为某一值的路径 直接遍历： class Solution { public: vector\u003cvector\u003cint\u003e\u003e pathSum(TreeNode* root, int sum) { vector\u003cvector\u003cint\u003e\u003e result; vector\u003cint\u003e path; if(root == nullptr)return result; traverse(root, sum, path, result); return result; } private: void traverse(TreeNode* root, int sum, vector\u003cint\u003e\u0026 path, vector\u003cvector\u003cint\u003e\u003e\u0026 result){ if(root == nullptr)return; sum -= root -\u003e val; path.push_back(root -\u003e val); if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr \u0026\u0026 sum == 0) result.push_back(path); traverse(root-\u003eleft, sum, path, result); traverse(root-\u003eright, sum, path, result); path.pop_back(); } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:32:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"35.复杂链表的复制 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。 在原来的链表每个节点后面复制该节点 复制 random 指针 拆分链表 留意复制 random 时为 clone -\u003e next -\u003e random = clone -\u003e random **-\u003e next**; class Solution { public: Node* copyRandomList(Node* head) { if(head == nullptr)return nullptr; Node* clone = head; // copy while(clone != nullptr){ Node* cloneNext = new Node(clone-\u003eval), *next = clone -\u003e next; cloneNext -\u003e next = next; clone -\u003e next = cloneNext; clone = next; } // copy random clone = head; while(clone != nullptr){ if(clone -\u003e random != nullptr) clone -\u003e next -\u003e random = clone -\u003e random **-\u003e next**; clone = clone -\u003e next -\u003e next; } // divide Node* cloneHead = head -\u003e next; clone = cloneHead; while(clone -\u003e next != nullptr){ head -\u003e next = clone -\u003e next; clone -\u003e next = clone -\u003e next -\u003e next; head = head -\u003e next; clone = clone -\u003e next; } head -\u003e next = nullptr; return cloneHead; } }; 关键是将原来的链表节点和新的链表节点一一对应，这里是 next，使用哈希可以变成map[oldNode]→newNode. ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:33:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"36.二叉搜索树与双向链表 搜索二叉树转换为双向链表 留意到搜索二叉树的中序遍历即为排序结果 排序的 双向的 循环的 递归记录 pre 指针和 head 指针： class Solution { public: Node* treeToDoublyList(Node* root) { if(root == nullptr)return nullptr; Node* pre = nullptr, *head = nullptr; traverse(head, pre, root); head -\u003e left = pre; pre -\u003e right = head; return head; } private: void traverse(Node*\u0026 head, Node*\u0026 pre, Node* root){ if(root == nullptr)return; if(head == nullptr \u0026\u0026 root -\u003e left == nullptr) head = root; if(root-\u003eleft) traverse(head, pre, root -\u003e left); if(pre != nullptr){ pre -\u003e right = root; root -\u003e left = pre; } pre = root; traverse(head, pre, root -\u003e right); return; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:34:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"37.序列化二叉树 先序遍历，注意减少字符串的复制: class Codec { public: string serialize(TreeNode* root) { string start =\"[\", end = \"]\"; string trans = serializeTraverse(root); return start.append(trans.substr(0, trans.size() - 1).append(end)); } TreeNode* deserialize(string data) { if(data.size() \u003c= 2)return nullptr; int pos = 1; return deserializeTraverse(data, pos); } private: string serializeTraverse(TreeNode* root){ if(root == nullptr)return \"null,\"; string result = to_string(root -\u003e val); string sign = \",\"; result = (result.append(sign)).append(serializeTraverse(root-\u003eleft)); result = result.append(serializeTraverse(root-\u003eright)); return result; } TreeNode* deserializeTraverse(string\u0026 data, int\u0026 pos){ if(pos \u003e= data.size())return nullptr; if(data.substr(pos, 4) == \"null\"){ pos += 5; return nullptr; } int posend = pos; while(data[posend] != ',' \u0026\u0026 data[posend] != ']')posend++; TreeNode* root = new TreeNode(stoi(data.substr(pos, posend - pos))); pos += posend - pos + 1; root -\u003e left = deserializeTraverse(data, pos); root -\u003e right = deserializeTraverse(data, pos); return root; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:35:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"38.字符串的排列 回溯法 class Solution { public: vector\u003cstring\u003e permutation(string s) { vector\u003cstring\u003e res; dfs(s, res, 0); return res; } void dfs(string \u0026s, vector\u003cstring\u003e \u0026res, int depth) { if(depth \u003e= s.size()-1) { res.push_back(s); return ; } unordered_set\u003cchar\u003e used; //局部set去重 for(int i = depth; i \u003c s.size(); ++i) { if(used.find(s[i]) != used.end()) continue; //去重 used.insert(s[i]); swap(s[depth],s[i]); dfs(s, res, depth+1); swap(s[depth],s[i]); //回溯撤销操作 } } }; 交换法 分别以每个元素作为开头，将后面的元素作为参数传入下一层递归： class Solution { public: vector\u003cstring\u003e permutation(string s) { vector\u003cstring\u003e res; dfs(res,s,0); return res; } void dfs(vector\u003cstring\u003e \u0026res,string \u0026s,int pos){ if(pos == s.size()) res.push_back(s); for(int i=pos;i\u003cs.size();i++){ bool flag = true; //s[pos] ~ s[i - 1] 为已经作为过开头的元素 for(int j = pos;j\u003ci;j++)//字母相同时，等效，剪枝 if(s[j] == s[i]) flag = false; if(flag){ swap(s[pos],s[i]); dfs(res,s,pos+1); swap(s[pos],s[i]); } } } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:36:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"39.数组中出现次数超过一半的数字 哈希表统计每个数字出现次数。时间复杂度和空间复杂度都是$O(n)$。 数组排序法。把数组排序后，中点一定是出现次数超过一半的数。时间复杂度为$O(n\\log_2n)$，空间复杂度为$O(1)$。 摩尔投票法。考虑让所有人来投票，最后的投票结果即为超过一半的数。时间复杂度$O(n)$ ，空间复杂度$O(1)$。 票数统计为 0 票，假设众数为 nums[0] 。 当票数大于 0，假设的众数不变；当等于 0，假设众数变为 nums[i+1] 。 class Solution { public: int majorityElement(vector\u003cint\u003e\u0026 nums) { if(nums.size() == 0)return -1; int most = nums[0]; int count = 1; for(int i = 1; i \u003c nums.size(); i++){ // cout \u003c\u003c most \u003c\u003c \" \" \u003c\u003c count \u003c\u003c endl; if(nums[i] == most)count++; else count--; if(count \u003c= 0){ most = nums[i + 1]; i++; count = 1; } } return most; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:37:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"40.数组的前 k 个最小的数 排序后取前 k 个数。时间复杂度$O(n\\log_2n)$，空间复杂度$O(n\\log_2n)$。 大小为 K 的最小堆 使用一个大根堆实时维护数组的前 k 个最小值。时间复杂度$O(n\\log k)$ 空间复杂度 $O(k)$。 使用c++中的 priority_queue ，底层为大根堆。 class Solution { public: vector\u003cint\u003e getLeastNumbers(vector\u003cint\u003e\u0026 arr, int k) { vector\u003cint\u003e vec; if(k == 0)return vec; priority_queue\u003cint\u003e heap; for(int i = 0; i \u003c k; i++){ heap.push(arr[i]); } for(int i = k; i \u003c arr.size(); i++){ if(arr[i] \u003c heap.top()){ heap.pop(); heap.push(arr[i]); } } for(int i = 0; i \u003c k; i++){ vec.push_back( heap.top()); heap.pop(); } return vec; } }; 利用快排函数快速切分 注意熟读快速排序函数 //严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) { int pivot = A[low]; while (low \u003c high) { while (low \u003c high \u0026\u0026 A[high] \u003e= pivot) { --high; } A[low] = A[high]; while (low \u003c high \u0026\u0026 A[low] \u003c= pivot) { ++low; } A[high] = A[low]; } A[low] = pivot; return low; } 若分割点\u003ek，即需要对左边进行分划 若分割点\u003ck，即需要对右边进行分割 class Solution { public: vector\u003cint\u003e getLeastNumbers(vector\u003cint\u003e\u0026 arr, int k) { vector\u003cint\u003e vec; if(k == 0)return vec; if(k \u003e= arr.size())return arr; int dividePos = -1; int start = 0, end = arr.size() - 1; while(dividePos != k){ dividePos = partition(start, end, arr); if(dividePos \u003c k)start = dividePos + 1; else if(dividePos \u003e k) end = dividePos - 1; } for(int i = 0; i \u003c k; i++){ vec.push_back(arr[i]); } return vec; } private: int partition(int l, int r, vector\u003cint\u003e\u0026 nums){ int pivot = nums[r]; int i = l - 1; for (int j = l; j \u003c= r - 1; ++j) { if (nums[j] \u003c= pivot) { i = i + 1; swap(nums[i], nums[j]); } } swap(nums[i + 1], nums[r]); return i + 1; } } ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:38:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"41.数据流中的中位数 设计一种数据结构，可以随时得到中位数 方法：大根堆+小根堆，各自记录一半的数。 class MedianFinder { public: MedianFinder() { m = 0; n = 0; } ~MedianFinder(){ } void addNum(int num) { if(num \u003c findMedian()){ small.push(num); n++; }else{ big.push(-num); m++; } while(m != n \u0026\u0026 m != n + 1){ if(m \u003e n){ AtoB(big, small); m--, n++; } else{ AtoB(small, big); n--, m++; } } } double findMedian() { if(m+n == 0)return 0.0; if((m+n) % 2 == 0)return (-big.top() + small.top()) / 2.0; else return -big.top(); } private: void AtoB(priority_queue\u003cint\u003e\u0026 A, priority_queue\u003cint\u003e\u0026 B){ B.push(-A.top()); A.pop(); } priority_queue\u003cint\u003e big, small; int m, n; }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:39:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"42.连续子数组的最大和 动态规划，dp[i]为以 i 字母为尾的最大和。 $$dp[i]=\\max {nums[i],\\ dp[i-1]+nums[i]}$$ class Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { if(nums.size() == 0)return INT_MIN; vector\u003cint\u003e dp(nums.size()); dp[0] = nums[0]; int maxSum = nums[0]; for(int i = 1; i \u003c nums.size(); i++){ dp[i] = max(nums[i], dp[i - 1] + nums[i]); maxSum = max(dp[i], maxSum); } return maxSum; } }; 可以降维压缩到 class Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { if(nums.size() == 0)return INT_MIN; int preSum = nums[0]; int maxSum = nums[0]; for(int i = 1; i \u003c nums.size(); i++){ preSum = max(nums[i], preSum + nums[i]); maxSum = max(preSum, maxSum); } return maxSum; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:40:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"43.n个整数的十进制表示中1出现的次数 **int countDigitOne(int n) { int ones = 0; for (long long m = 1; m \u003c= n; m *= 10) ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1); return ones; }** 4+ lines, O(log n), C++/Java/Python - LeetCode Discuss ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:41:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"44.数字序列中的某一位数字 一位数，两位数，三位数，四位数对应的个数是10, 90, 900, 9000 class Solution { public: int findNthDigit(int n) { if (n \u003c 10) return n; /*一位数，两位数，三位数，四位数对应的个数是10, 90, 900, 9000*/ int bit(1); long long lev(10), temp(1), index(1); /*累计现在的位数index*/ while (1) { temp += (lev / 10) * 9 * bit; /*如果index大于n，结束*/ if (n - temp \u003c 0) break; index = temp; lev *= 10; ++bit; } /*求取当前的数是什么*/ int num = (n - index) / bit + (lev / 10); /*要求是这个数的第几位*/ int xindex = (n - index) % bit; /*顺序从高到低，所以反过来求要除以10^x*/ int div = pow(10, bit - xindex - 1); /*返回该位*/ return (num / div) % 10; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:42:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"45.把数组排成最小的数 优先让首位数字最小，自定义 compare 函数 class Solution { public: string minNumber(vector\u003cint\u003e\u0026 nums) { string result = \"\"; if(nums.size() == 0)return result; if(nums.size() == 1)return to_string(nums[0]); vector\u003cstring\u003e data; for(auto item : nums)data.push_back(to_string(item)); sort(data.begin(), data.end(), compare); for(auto item: data)result.append(item); return result; } private: **static** bool compare(const string\u0026 a, const string\u0026 b){ return a+b \u003c b+a; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:43:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"46.把数字翻译成字符串 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 动态规划： class Solution { public: int translateNum(int num) { string nums = to_string(num); int count = nums.size(); vector\u003cint\u003e dp(count, 0); dp[0] = 1; for(int i = 1; i \u003c nums.size(); i++){ dp[i] += dp[i - 1]; if(nums[i - 1] == '1' || (nums[i - 1] == '2') \u0026\u0026 nums[i] \u003c= '5') dp[i] += i \u003e 1? dp[i - 2]: 1; } return dp[nums.size() - 1]; } }; 降维： class Solution { public: int translateNum(int num) { string nums = to_string(num); int count = nums.size(); int dp0 = 1, dp1 = 1, dp2 = 0; for(int i = 1; i \u003c nums.size(); i++){ dp2 += dp1; if(nums[i - 1] == '1' || (nums[i - 1] == '2') \u0026\u0026 nums[i] \u003c= '5') dp2 += (i \u003e 1)? dp0: 1; dp0 = dp1, dp1 = dp2, dp2 = 0; } return dp1; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:44:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"47.礼物的最大价值 动态规划： class Solution { public: int maxValue(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { vector\u003cvector\u003cint\u003e\u003e dp(grid.size(), vector\u003cint\u003e(grid[0].size())); dp[0][0] = grid[0][0]; for(int i = 0; i \u003c grid.size(); i++){ for(int j = 0; j \u003c grid[0].size(); j++){ if(i == 0 \u0026\u0026 j == 0)continue; if(i == 0)dp[i][j] = dp[i][j - 1] + grid[i][j]; else if(j == 0)dp[i][j] = dp[i - 1][j] + grid[i][j]; else dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1]); } } return dp[grid.size() - 1][grid[0].size() - 1]; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:45:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"48.最长不含重复字符的子字符串 滑动窗口+哈希 class Solution { public: int lengthOfLongestSubstring(string s) { map\u003cchar, int\u003e m; int ret = 0, l = 0, r = 0; while (r \u003c s.size()) { if (m.find(s[r]) != m.end()) { **l = max(l, m[s[r]] + 1); //忽略以前发生的冲突** } m[s[r]] = r; r++; ret = max(r - l, ret); } return ret; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:46:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"49.丑数 要维持一个 N 长的数组，和三个 index，每次选择下次要走哪个 index. $$dp[i] = \\min(dp[a]*2,dp[b]*3,dp[c]*5)$$ class Solution { public: int nthUglyNumber(int n) { if (n \u003c= 6)return n; vector\u003cint\u003e dp(n); dp[0] = 1; int i2 = 0, i3 = 0, i5 = 0; for(int i = 1; i \u003c n; i++){ // cout \u003c\u003c dp[i2] \u003c\u003c \" \" \u003c\u003c dp[i3] \u003c\u003c \" \" \u003c\u003c dp[i5] \u003c\u003c endl; dp[i] = min(dp[i2] * 2, min(dp[i3] * 3, dp[i5] * 5)); // cout \u003c\u003c dp[i] \u003c\u003c endl; **if(dp[i] == dp[i2] * 2)i2++; if(dp[i] == dp[i3] * 3)i3++; if(dp[i] == dp[i5] * 5)i5++; //注意这里不能重复计算路径 如2x3 vs 3x2** } return dp[n - 1]; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:47:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"50.第一个只出现一次的字符 unordered_map class Solution { public: char firstUniqChar(string s) { unordered_map\u003cchar, int\u003e m; for(auto item: s)m[item]++; for(auto item: s) if(m[item] == 1)return item; return ' '; } }; C++中要实现有序哈希的话，需要额外储存 vector 保存 keys。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:48:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"51. 数组中的逆序对 归并排序算法：在 merge 时，right 数组的元素与 left 数组中剩下的元素都为逆序组。 class Solution { public: int reversePairs(vector\u003cint\u003e\u0026 nums) { int len = nums.size(); if (len \u003c 2) { return 0; // 若不存在数对，直接 return 0 } vector\u003cint\u003e helper(len); return reversePairs(nums, 0, len - 1, helper); } private: int reversePairs(vector\u003cint\u003e\u0026 nums, int left, int right, vector\u003cint\u003e\u0026 helper) { if (left == right) { return 0; // 递归终止条件是只剩一个元素了（即不存在数对了） } int mid = left + (right - left) / 2; // 此算式等同于 (left + right) / 2，是为了避免溢出 int leftPairs = reversePairs(nums, left, mid, helper); // 计算左半部分的逆序对 int rightPairs = reversePairs(nums, mid + 1, right, helper); // 计算右半部分的逆序对 if (nums[mid] \u003c= nums[mid + 1]) { // 此判断用于加速，即如果左右都已排好序，而且左边的最大值 \u003c= 右边的最小值， // 那么就不存在跨越左边和右边的逆序对了 return leftPairs + rightPairs; } int crossPairs = mergeAndCount(nums, left, mid, right, helper); // 计算跨越左边和右边的逆序对 return leftPairs + rightPairs + crossPairs; } int mergeAndCount(vector\u003cint\u003e\u0026 nums, int left, int mid, int right, vector\u003cint\u003e\u0026 helper) { // 本函数的前提条件是：左半部分和右半部分都是已经按升序排好序了的 // 因为本函数是从左右部分都是只有一个元素的情况开始运行的（自底向上），所以是可以保证前提条件的 for (int i = left; i \u003c= right; ++i) { helper[i] = nums[i]; // 先填充 helper 辅助数组 } int i = left, j = mid + 1; // i 和 j 分别是左半部分和右半部分的起点 int count = 0; // count 用来统计逆序对数量 for (int k = left; k \u003c= right; ++k) { if (i == mid + 1) { // 假如 i 已经越过左边的边界，直接填充右半部分进 nums nums[k] = helper[j]; ++j; } else if (j == right + 1) { // 假如 j 已经越过右边的边界，直接填充左半部分进 nums nums[k] = helper[i]; ++i; } else if (helper[i] \u003c= helper[j]) { // 注意健壮的归并排序这里要是 \u003c= // 假如左边小于等于右边，那就不是逆序对，不用修改 count nums[k] = helper[i]; ++i; } else { // 假如左边大于右边，是逆序对，count += 当前左边 [i, mid] 的所有元素 // 因为假如左边是 [7,8]，右边是[5,6]，然后 i 指向 7，j 指向 5 // 那么 5 和 7、8 都构成了逆序对，也就是此时有两对新的逆序对 // 所以可以总结出规律：count += mid - i + 1 nums[k] = helper[j]; count += mid - i + 1; ++j; } } return count; } }; //作者：superkakayong //链接：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/zi-jie-ti-ku-jian-51-kun-nan-shu-zu-zhon-eipc/ //来源：力扣（LeetCode） ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:49:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"52. 两个链表的第一个公共节点 双指针法：两个指针分别走链 A，链 B 和链 B，链 A，相遇时即为第一个公共节点。 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* pa = headA, * pb = headB; while(pa != pb){ pa = pa ? pa -\u003e next : headB; pb = pb ? pb -\u003e next : headA; } return pa; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:50:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"53-I.在排序数组中寻找数字 牢记二分法搜寻左右边界的模板(左闭右开)： 左边界： int binarySearchLeft(int left, int right, vector\u003cint\u003e\u0026 nums, int target){ int mid; while(left \u003c right){ mid = left + (right - left) / 2; if(nums[mid] == target){ right = mid; } else if(nums[mid] \u003c target){ left = mid + 1; } else if(nums[mid] \u003e target){ right = mid; } } return left \u003e= 0 \u0026\u0026 left \u003c nums.size() \u0026\u0026 nums[left] == target ? left : -1; } 右边界： int binarySearchRight(int left, int right, vector\u003cint\u003e\u0026 nums, int target){ int mid; while(left \u003c right){ mid = left + (right - left) / 2; if(nums[mid] == target){ left = mid + 1; } else if(nums[mid] \u003c target){ left = mid + 1; } else if(nums[mid] \u003e target){ right = mid; } } return left - 1; } 算法代码呼之欲出 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { if(nums.size() == 0)return 0; int leftIndex = binarySearchLeft(0, nums.size(), nums, target); if(leftIndex == -1) return 0; int rightIndex = binarySearchRight(0, nums.size(), nums, target); return rightIndex - leftIndex + 1; } private: int binarySearchLeft(int left, int right, vector\u003cint\u003e\u0026 nums, int target){ int mid; while(left \u003c right){ mid = left + (right - left) / 2; if(nums[mid] == target){ right = mid; } else if(nums[mid] \u003c target){ left = mid + 1; } else if(nums[mid] \u003e target){ right = mid; } } return left \u003e= 0 \u0026\u0026 left \u003c nums.size() \u0026\u0026 nums[left] == target ? left : -1; } int binarySearchRight(int left, int right, vector\u003cint\u003e\u0026 nums, int target){ int mid; while(left \u003c right){ mid = left + (right - left) / 2; if(nums[mid] == target){ left = mid + 1; } else if(nums[mid] \u003c target){ left = mid + 1; } else if(nums[mid] \u003e target){ right = mid; } } return left - 1; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:51:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"53-II 0～n-1中缺失的数字 即二分搜索正确排列的数组的右边界右边的那个 index。 class Solution { public: int missingNumber(vector\u003cint\u003e\u0026 nums) { int left = 0, right = nums.size(), mid; while(left \u003c right){ mid = left + (right - left) / 2; if(nums[mid] == mid){ left = mid + 1; }else{ right = mid; } } return left; //不需要 left - 1 } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:52:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"54. 二叉搜索树的第k大节点 二叉搜索树right，root，left 的遍历即为从大到小的遍历。 class Solution { public: int kthLargest(TreeNode* root, int\u0026 k) { int val = root -\u003e val; if(root -\u003e right)val = kthLargest(root -\u003e right, k); if(k == 0)return val; if(--k == 0)return root -\u003e val; if(root -\u003e left)return kthLargest(root -\u003e left, k); return 0; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:53:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"55 - I. 二叉树的深度 后序遍历方法：此树的深度 等于 左子树的深度 与 右子树的深度 中的 最大值 + 1 。 时间复杂度是$O(n)$。 class Solution { public: int maxDepth(TreeNode* root) { if(root == nullptr)return 0; return max(maxDepth(root -\u003e left) + 1, maxDepth(root -\u003e right) + 1); } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:54:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"55-II.平衡二叉树的判断 自顶向下方法，时间复杂度为$O(n\\log n)$。 class Solution { public: bool tranverse(TreeNode* root, int\u0026 height){ int left = 0, right = 0; if(root -\u003e left != nullptr){ left ++; if(!tranverse(root -\u003e left, left)){ return false; } } if (root-\u003eright != nullptr) { right ++; if (!tranverse(root-\u003eright, right)) { return false; } } height = height + max(left, right); if(abs(left - right) \u003e 1)return false; else return true; } bool isBalanced(TreeNode* root) { if(root == nullptr)return true; int height; return tranverse(root, height); } }; 自底向上方法，时间复杂度为$O(n)$。利用上面的 maxdepth 函数。 class Solution { public: int maxDepth(TreeNode* root) { if(root == nullptr)return 0; return max(maxDepth(root -\u003e left) + 1, maxDepth(root -\u003e right) + 1); } bool isBalanced(TreeNode* root) { if(root == nullptr)return true; return abs(maxDepth(root -\u003e left) - maxDepth(root -\u003e right)) \u003c 2 \u0026\u0026 isBalanced(root -\u003e left) \u0026\u0026 isBalanced(root -\u003e right); } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:55:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"56 - I. 数组中数字出现的次数 排序后单指针，时间复杂度不符合要求，为$O(N\\log N)$。 class Solution { public: vector\u003cint\u003e singleNumbers(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); vector\u003cint\u003eresult; int i = 1; for(; i \u003c nums.size(); ){ // cout \u003c\u003c nums[i - 1] \u003c\u003c \" \" \u003c\u003c nums[i] \u003c\u003c endl; if(nums[i] != nums[i - 1]){ result.push_back(nums[(i++) - 1]); }else{ i += 2; } } if(i == nums.size())result.push_back(nums[i - 1]); return result; } }; 利用异或交换律+二分 力扣 异或： 交换律：a ^ b ^ c \u003c=\u003e a ^ c ^ b 任何数于0异或为任何数 0 ^ n =\u003e n 相同的数异或为0: n ^ n =\u003e 0 把所有数字异或，得到一个数，这个数必定是两个只出现一次的数字异或得到的。异或规则是两个相应的bit位相同为0，不同为1。根据这个任意找一个为1的数位，根据这个数位为0和1分成两个数组，这样必定把两个结果数分开了，再分别异或就能得到结果。 class Solution { public: vector\u003cint\u003e singleNumbers(vector\u003cint\u003e\u0026 nums) { int exor = 0; for (int i : nums) { exor ^= i; // 求出两个独立数字的异或值 } int first1 = 1; while (!(first1 \u0026 exor)) { first1 \u003c\u003c= 1; // 找到该异或值从右往左第一个 1 出现的位置 } int a = 0, b = 0; for (int i : nums) { if (i \u0026 first1) { a ^= i; // 如果 i 从右往左第一个 1 出现的位置与异或值一样 } else { b ^= i; // 如果 i 从右往左第一个 1 出现的位置与异或值不一样 } } return {a, b}; } }; //作者：superkakayong //链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/zi-jie-ti-ku-jian-56-i-zhong-deng-shu-zu-rdni/ //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:56:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"56 - II. 数组中数字出现的次数 II 哈希表方法，过于简单 sort 也很简单 位运算法 力扣 class Solution { public: int singleNumber(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e binary(32, 0); // 因为 int 最大到 2^31，所以二进制形式最大为 32 位 for (int i : nums) { for (int j = 31; j \u003e= 0; --j) { // 将 nums 的所有元素转为二进制并加起来 binary[j] += i \u0026 1; i \u003e\u003e= 1; } } int res = 0; for (int j = 31; j \u003e= 0; --j) { // 哪一位不能被3整除，就说明目标数字的二进制在那一位是 1 if (binary[j] % 3 != 0) { res += pow(2, (31 - j)); } } return res; } }; /* 作者：superkakayong 链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/zi-jie-ti-ku-jian-56-ii-zhong-deng-shu-z-qbp1/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/ ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:57:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"57. 和为s的两个数字 hash 表 对每一个元素二分 双指针法： 正确性证明： 力扣 class Solution { public: vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { int i = 0, j = nums.size() - 1; while(nums[i] + nums[j] != target){ if(target \u003c nums[i] + nums[j])j--; else i++; } return {nums[i], nums[j]}; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:58:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"57 - II. 和为s的连续正数序列 数学优化法： 可分为偶数i份：最小的数大于 0 \u0026\u0026 可以以连续整数分为 i 份（即最小的数%i ==0） 可分为奇数i份：最小的数大于 0 \u0026\u0026 可以平均分为 i 份，中间的为平均数 class Solution { public: vector\u003cvector\u003cint\u003e\u003e findContinuousSequence(int target) { vector\u003cvector\u003cint\u003e\u003e result; for(int i = target / 2; i \u003e= 2; i--){ if((target / i - i / 2 + 1 \u003e 0 \u0026\u0026 i % 2 == 0 \u0026\u0026 (target - (i*(i-1)/2) ) % i == 0 ) || (target / i - i / 2\u003e 0 \u0026\u0026 i % 2 == 1 \u0026\u0026 target % i == 0) ){ vector\u003cint\u003e temp; for(int j = (target / i) - i / 2 + (i % 2 == 0); j \u003c= (target / i) + i / 2; j++){ temp.push_back(j); } result.push_back(temp); } } return result; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:59:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"58-I.反转单词顺序 注意空格的处理，指针+字符串拼接方法： class Solution { public: string reverseWords(string s) { vector\u003cstring\u003e resList; for(int i = s.size() - 1; i \u003e= 0; i--){ if(s[i] == ' ')continue; // cout \u003c\u003c \"=\u003e i = \" \u003c\u003c i \u003c\u003c \" s[i]: \" \u003c\u003c s[i] \u003c\u003c endl; int j = i; while(j \u003e= 0 \u0026\u0026 s[j] != ' ')j--; if(j != i)resList.push_back(s.substr(j + 1, i - j)); i = j; } string result = \"\"; int flag = 0; for(auto si: resList){ // cout \u003c\u003c \"\\\"\" \u003c\u003c si \u003c\u003c \"\\\" \"; if(flag == 1)result.append(\" \"); result.append(si); flag = 1; } return result; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:60:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"58 - II. 左旋转字符串 直接分割为两部分，拼接 class Solution { public: string reverseLeftWords(string \u0026s, int n) { if(n \u003e= s.size())return s; string left = s.substr(0, n), right = s.substr(n, s.size() - n); return right.append(left); } }; 空间复杂度$O(s.size())$。 只保存$\\min(k,s.size()-k)$大小的数组，降低空间复杂度： class Solution { public: string reverseLeftWords(string \u0026s, int k) { if(k \u003e= s.size())return s; if(k \u003c= s.size() / 2){ string temp = s.substr(k, s.size() - k); for(int i = 0; i \u003c k; i++){ s[s.size() - k + i] = s[i]; } for(int i = 0; i \u003c s.size() - k; i++){ s[i] = temp[i]; } } else{ string temp = s.substr(0, k); for(int i = 0; i \u003c s.size() - k; i++){ s[i] = s[k + i]; } for(int i = 0; i \u003c k; i++){ s[s.size() - k + i] = temp[i]; } } return s; } }; 先反转前 k 个字符，再反转后面的字符，最后整体反转。 空间复杂度$O(1)$，时间复杂度$O(n\\log n)$。 class Solution { public: string reverseLeftWords(string \u0026s, int k) { if(k \u003e= s.size())return s; reverse(s.begin(), s.begin() + k); reverse(s.begin() + k, s.end()); reverse(s.begin(), s.end()); return s; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:61:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"59-I.滑动窗口的最大值 窗口对应的数据结构为 双端队列 ，本题使用 单调双向队列 即可解决以上问题。 力扣 class Solution { public: vector\u003cint\u003e maxSlidingWindow(vector\u003cint\u003e\u0026 nums, int k) { if(nums.size() == 0)return {}; deque\u003cint\u003e q; vector\u003cint\u003e result; for(int i = 0; i \u003c nums.size(); i++){ if(q.empty()){ q.push_back(i); } else{ // 检查过期的元素 while(!q.empty() \u0026\u0026 q.front() \u003c= i - k)q.pop_front(); // 删除前面无用的较小元素 while(!q.empty() \u0026\u0026 nums[q.front()] \u003c nums[i])q.pop_front(); // 删除后面较小的元素，保证有序性 while(!q.empty() \u0026\u0026 nums[q.back()] \u003c nums[i])q.pop_back(); q.push_back(i); } if(i \u003e= k - 1)result.push_back(nums[q.front()]); } return result; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:62:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"59 - II. 队列的最大值 利用上题的滑动窗口思想，用一个 deque记录 maxvalue 的情况： class MaxQueue { public: MaxQueue() { } int max_value() { if(data.empty())return -1; return maxQueue.front(); } void push_back(int value) { while(!maxQueue.empty() \u0026\u0026 maxQueue.front() \u003c value)maxQueue.pop_front(); while(!maxQueue.empty() \u0026\u0026 maxQueue.back() \u003c value)maxQueue.pop_back(); data.push(value); maxQueue.push_back(value); } int pop_front() { if(data.empty())return -1; int val = data.front(); if(val == max_value()){ maxQueue.pop_front(); } data.pop(); return val; } private: queue\u003cint\u003e data; deque\u003cint\u003e maxQueue; }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:63:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"60. n个骰子的点数 动态规划：把每投一个骰子作为一个阶段i，转移方程为 $$dp[i][sum]=\\sum_{value_i=1}^6 dp[i-1][sum-value_i]$$ class Solution { public: vector\u003cdouble\u003e dicesProbability(int n) { int maxPossible = 6*n; vector\u003cvector\u003cdouble\u003e\u003e dp(n, vector\u003cdouble\u003e(maxPossible + 1, 0)); for(int i = 1; i \u003c= 6; ++i){ dp[0][i] = 1; } for(int i = 1; i \u003c n; ++i){ for(int j = i + 1; j \u003c= 6 * (i + 1); j++){ for(int z = 1; z \u003c= 6; z++){ if(j - z \u003e 0)dp[i][j] += dp[i - 1][j - z]; } } } int all = pow(6, n); vector\u003cdouble\u003e result(dp[n - 1].begin() + n, dp[n - 1].end()); for(auto \u0026 item: result)item /= all; return result; } }; 可以降维为两个数组： class Solution { public: vector\u003cdouble\u003e dicesProbability(int n) { int maxPossible = 6*n; vector\u003cdouble\u003e pre (maxPossible + 1, 0); vector\u003cdouble\u003e* cur; for(int i = 1; i \u003c= 6; ++i){ pre[i] = 1; } for(int i = 1; i \u003c n; ++i){ cur = new vector\u003cdouble\u003e(maxPossible + 1, 0); for(int j = i + 1; j \u003c= 6 * (i + 1); j++){ for(int z = 1; z \u003c= 6; z++){ if(j - z \u003e 0)(*cur)[j] += pre[j - z]; } } pre = *cur; delete cur; } int all = pow(6, n); vector\u003cdouble\u003e result(pre.begin() + n, pre.end()); for(auto \u0026 item: result)item /= all; return result; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:64:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"61. 扑克牌中的顺子 滑动窗口，用数组存储某张牌是否出现： class Solution { public: bool isStraight(vector\u003cint\u003e\u0026 nums) { int jorkerCount = 0; vector\u003cbool\u003e cards(13, false); for(auto ni: nums){ if(ni == 0)jorkerCount++; else cards[ni - 1] = true; } for(int i = 0; i \u003c 9; ++i){ int straight = jorkerCount; for(int j = 0; j \u003c 5; j++){ straight += cards[i + j]; } if(straight == 5)return true; } return false; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:65:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"62. 圆圈中最后剩下的数字 约瑟夫环问题： 用$f(N,M)$代表 N 个人报数，报到 M 时去掉那个人， 最终胜利者的坐标。递推公式为 $$f(N,M)=(f(N-1,M)+M)%N$$ 约瑟夫环–公式法（递推公式）_再难也要坚持-CSDN博客_约瑟夫环公式 class Solution { public: int lastRemaining(int n, int m) { int f = 0; for (int i = 2; i != n + 1; ++i) { f = (m + f) % i; } return f; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:66:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"63.股票的最大利润 我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。 class Solution { public: int maxProfit(vector\u003cint\u003e\u0026 prices) { int n = prices.size(); if(n == 0)return 0; // i 天卖出能得到的最大利润 vector\u003cint\u003e dp(n); dp[0] = -prices[0]; int result = 0; int buyPrices = -prices[0]; for(int i = 1; i \u003c prices.size(); i++){ buyPrices = max(buyPrices, -prices[i]); dp[i] = buyPrices + prices[i]; result = max(result, dp[i]); } return result; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:67:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"64.求 1+2+…+n 要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 class Solution { public: int sumNums(int n) { int sum = n; bool t = (n \u003e 0 \u0026\u0026 (sum += sumNums(n - 1)) ); return sum; } }; 利用了\u0026\u0026的短路规则，实际上也是一个 if 判断 官方题解： class Solution { public: int sumNums(int n) { int ans = 0, A = n, B = n + 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; (B \u0026 1) \u0026\u0026 (ans += A); A \u003c\u003c= 1; B \u003e\u003e= 1; return ans \u003e\u003e 1; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:68:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"65.不用加减乘除做加法 a ^ b 表示没有考虑进位的情况下两数的和，(a \u0026 b) « 1 就是进位。 递归会终止的原因是 (a \u0026 b) « 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。 int add(int a, int b) { return b == 0 ? a : add(a ^ b, (a \u0026 b) \u003c\u003c 1); } ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:69:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"66.构建乘积数组 一次遍历就可以完成。 class Solution { public: vector\u003cint\u003e constructArr(vector\u003cint\u003e\u0026 a) { if(a.size() == 0)return {}; vector\u003cint\u003e b(a.size(), 1); int leftBase = 1, rightBase = 1; for(int i = 0; i \u003c a.size(); i++){ b[i] *= leftBase; leftBase *= a[i]; b[a.size() - i - 1] *= rightBase; rightBase *= a[a.size() - i - 1]; } return b; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:70:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"67. 把字符串转换成整数 class Solution { public: int strToInt(string str) { long x=0; int nsigned=0; //记录是否已经读取到符号 -1为加号 +1为减号 int numbered = 0 ; //记录是否已经读取过数字 char t; for(int i=0;i\u003cstr.size();i++){ t=str[i]; if(t=='-' || t=='+'){ if(nsigned!=0||numbered==1) break; else{ if(t=='-')nsigned=1; else nsigned=-1; } } else if(t==' '\u0026\u0026 numbered==0 \u0026\u0026 nsigned==0) continue; else if((t\u003c'0'||t\u003e'9')){ if(numbered==1) break; else return 0; } else{ x=10*x+t-'0'; if((nsigned != 1) \u0026\u0026 x\u003eINT_MAX)return INT_MAX; if((nsigned == 1) \u0026\u0026 -x\u003cINT_MIN)return INT_MIN; numbered = 1; } } if(nsigned==1) x=-x; //跳出循环后若已经读取到减号,则取负数 return x; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:71:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"68-I.二叉搜索树的最近共同祖先 利用好二叉搜索树的性质： class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr)return nullptr; if(p -\u003e val \u003c root -\u003e val \u0026\u0026 q -\u003e val \u003c root -\u003e val) return lowestCommonAncestor(root -\u003e left, p, q); else if(p -\u003e val \u003e root -\u003e val \u0026\u0026 q -\u003e val \u003e root -\u003e val) return lowestCommonAncestor(root -\u003e right, p, q); else return root; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:72:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"68-II.二叉树的最近共同祖先 递归，理清返回参数的情况： class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr)return nullptr; if(p -\u003e val == root -\u003e val || q -\u003e val == root -\u003e val)return root; TreeNode* left = lowestCommonAncestor(root -\u003e left, p, q), *right = lowestCommonAncestor(root -\u003e right, p, q); if(left \u0026\u0026 right)return root; else return left? left: right; } }; ","date":"2021-01-08","objectID":"/%E5%89%91%E6%8C%87offer/:73:0","tags":["Coding","LeetCode"],"title":"刷题-剑指Offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":null,"content":"Linux From Scratch (LFS) is a project that provides you with step-by-step instructions for building your own customized Linux system entirely from source. ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:0","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"准备工作 环境:parallels虚拟机 下载LFS-LiveCD的ISO文件(6.3版本) 用虚拟机打开,选择为Linux Kernel 2.6. passwd更改密码 /etc/rc.d/init.d/sshd start 启动ssh服务 ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:1","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"分区 使用cfdisk创建两个分区 mkswap /dev/sda1 mke2fs -jv /dev/sda2 sda1作为交换分区,sda2作为ext3格式分区. ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:2","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"工作环境设置 export LFS=/mnt/lfs mkdir -pv $LFS mount /dev/sda2 $LFS swapon /dev/sda1 ln -sv $LFS/tools / groupadd lfs useradd -s /bin/bash -g lfs -m -k /dev/null lfs passwd lfs chown -v lfs $LFS/tools chown -v lfs $LFS/sources su - lfs cat \u003e ~/.bash_profile \u003c\u003c \"EOF\" exec env -i HOME=$HOME TERM=$TERM PS1='\\u:\\w\\$ ' /bin/bash EOF cat \u003e ~/.bashrc \u003c\u003c \"EOF\" set +h umask 022 LFS=/mnt/lfs LC_ALL=POSIX LFS_TGT=$(uname -m)-lfs-linux-gnu PATH=/tools/bin:/bin:/usr/bin export LFS LC_ALL PATH EOF source ~/.bash_profile 新建了一个lfs用户,并赋予其编译工具链的目录和权限,并设置一些环境变量. ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:3","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"工具链编译 cd $LFS/sources 里面是工具链的软件包,大约需要安装26个. 逐个编译起来 Binutils GCC-4.1.2 Linux-2.6.22.1 API Headers Glibc (The Glibc package contains the main C library. This library provides the basic routines for allocating memory, searching directories, opening and closing files, reading and writing files, string handling, pattern matching, arithmetic, and so on.)] ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:4","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"链接编译工具链到编译过的GCC ​ 过程略.继续编译其他包 Tcl(This package and the next two (Expect and DejaGNU) are installed to support running the test suites for GCC and Binutils. Installing three packages for testing purposes may seem excessive, but it is very reassuring, if not essential, to know that the most important tools are working properly. Even if the test suites are not run in this chapter (they are not mandatory), these packages are required to run the test suites in Chapter 6.) Expect DejaGNU(The DejaGNU package contains a framework for testing other programs.) Ncurses-5.6 Bash-3.2 Bzip2-1.0.4 Coreutils-6.9(The Coreutils package contains utilities for showing and setting the basic system characteristics.) Diffutils-2.8.1(The Diffutils package contains programs that show the differences between files or directories.) Findutils-4.2.31(The Findutils package contains programs to find files. These programs are provided to recursively search through a directory tree and to create, maintain, and search a database (often faster than the recursive find, but unreliable if the database has not been recently updated).) Gawk-3.1.5 Gettext-0.16.1(The Gettext package contains utilities for internationalization and localization. These allow programs to be compiled with NLS (Native Language Support), enabling them to output messages in the user’s native language.) grep Gzip-1.3.12 Make-3.81 Patch-2.5.4 Perl-5.8.8 Sed-4.1.5 Tar-1.18 Texinfo-4.9(The Texinfo package contains programs for reading, writing, and converting info pages.) Util-linux-2.12r(The Util-linux package contains miscellaneous utility programs. Among them are utilities for handling file systems, consoles, partitions, and messages.) ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:5","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"内核编译安装 chroot到新系统下的root,编写fstab和编译安装内核 内核选项配置(sda,parallel) 因为我是用的是 parallel 虚拟机，需要配置特殊的硬盘配置。 make menuconfig Device Drivers |—\u003e SCSI device support ​ |—\u003e \u003c*\u003e SCSI device support ​ |—\u003e \u003c*\u003e SCSI disk support |—\u003e \u003c*\u003e Serial ATA (prod) and Parallel ATA (experimental) drivers ​ |—\u003e \u003c*\u003e AHCI SATA support ​ |—\u003e \u003c*\u003e Intel ESB, ICH, PIIX3, PIIX4 PATA/SATA support (NEW) ​ |—\u003e \u003c*\u003e Intel PATA old PIIX support (NEW) File systems |—\u003e \u003c*\u003e Ext3 journalling file system support |—\u003e [*] Ext3 extended attributes |—\u003e [*] Ext3 POSIX Access Control Lists ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:6","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"设置Grub引导(sda2分区块,parallels环境) cat \u003e /etc/fstab \u003c\u003c \"EOF\" # Begin /etc/fstab # file system mount-point type options dump fsck # order /dev/sda2 / ext2 defaults 1 1 /dev/sda1 swap swap pri=1 0 0 proc /proc proc defaults 0 0 sysfs /sys sysfs defaults 0 0 devpts /dev/pts devpts gid=4,mode=620 0 0 shm /dev/shm tmpfs defaults 0 0 # End /etc/fstab EOF cat \u003e /boot/grub/menu.lst \u003c\u003c \"EOF\" # Begin /boot/grub/menu.lst # By default boot the first menu entry. default 0 # Allow 30 seconds before booting the default. timeout 5 # Use prettier colors. color green/black light-green/black # The first entry is for LFS. title LFS 6.3 root (hd0,1) kernel /boot/lfskernel-2.6.22.5 root=/dev/sda2 EOF grub root (hd0,1) setup (hd0) quit 重启顺利进入LFS系统. ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:7","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"安装openssh 返回livecd下载编译安装wget,接着升级perl到最新版本,安装openssl和openssh. 至此系统环境顺利搭建. ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:8","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"安装Xwindow,运行Qt软件 此处参考了https://blog.csdn.net/u012333520/article/details/50563462 最后成功编译qt-4.1.0.虽然是比较旧的版本,但是作为课设的编译工具也够用了. 最后利用 qt 完成了一个进程管理器和一个计算器。 ","date":"2020-08-18","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/:0:9","tags":["Project","CS","OS"],"title":"制作自己的 LFS 项目（操作系统课设）","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-lfs%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"教程地址: https://cstack.github.io/db_tutorial/ 实现一个简化版的数据库。架构设计如下: ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"Part1 设置REPL(交互式解释器) “读取-求值-输出”循环（英语：Read-Eval-Print Loop，简称REPL），也被称做交互式顶层构件（英语：interactive toplevel），是一个简单的，交互式的编程环境。这个词常常用于指代一个Lisp的交互式开发环境，也能指代命令行的模式。 查询路径:Tokenizer-\u003e解析器-\u003e代码生成器-\u003e虚拟机-\u003eB树-\u003ePager-\u003e操作系统 ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:1","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"最简单的REPL环境: 前提知识: size_t 与 ssize_t类型是为了方便操作系统之间移植的一种计数类型(unsigned_int与signed int). 两者包含在C的stddef.h中和C++的cstddef中(也可不include). size_t x; ssize_t y; printf(\"%zu\\n\", x); // prints as unsigned decimal printf(\"%zx\\n\", x); // prints as hex printf(\"%zd\\n\", y); // prints as signed decimal stdlib.h是C标准函数库的头文件，声明了数值与字符串转换函数, 伪随机数生成函数, 动态内存分配函数, 进程控制函数等公共函数。 C++程序应调用等价的 cstdlib 头文件. C语言的标准函数库中的头文件stdbool.h在C99中引入，包含四个用于布尔型的预定义宏。 IEEE 1003.1-2001标准中的宏定义包括: bool，会扩展为_Bool true，会扩展为1 false，会扩展为0 __bool_true_false_are_defined，会扩展为1 ssize_t getline(char **lineptr, size_t *n, FILE *stream); ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:2","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"REPL demo: 围绕InputBuffer和getline()函数写一个死循环(非完整代码) typedef struct { char * buffer; size_t buffer_length; ssize_t input_length; }InputBuffer; //buffer int main(int argc, char* argv[]) { InputBuffer* input_buffer = new_input_buffer(); while (true) { print_prompt(); read_input(input_buffer); if (strcmp(input_buffer-\u003ebuffer, \".exit\") == 0) { close_input_buffer(input_buffer); exit(EXIT_SUCCESS); } else { printf(\"Unrecognized command '%s'.\\n\", input_buffer-\u003ebuffer); } } } ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:3","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"Part2 SQL编译器和虚拟机 分成编译器和虚拟机的好处是,虚拟机不需要担心语法上的错误. 修改代码 ​ 若语句以.开头,则判断为meta_command 并执行 ​ 若判断为普通语句,则,则用prepare_statement来执行语句 这里返回的两个结构体分别为 typedef enum { META_COMMAND_SUCCESS, META_COMMAND_UNRECOGNIZED_COMMAND } MetaCommandResult; //meta_command result typedef enum { PREPARE_SUCCESS, PREPARE_UNRECOGNIZED_STATEMENT } PrepareResult; 这里的枚举类型复习一下: enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; //等价于定义 #define MON 1 #define TUE 2 #define WED 3 #define THU 4 #define FRI 5 #define SAT 6 #define SUN 7 这里还牵涉到strncmp的用法 strncmp(str1,str2,n)==0; //n代表对前n个字符作比较 定义了多种状态类型来返回函数状态,且通过strncmp来识别insert操作 这里所谓的编译是非常简化的编译操作(甚至大写的select都无法识别) ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:4","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"Part3 In-Memory,Append-Only,Single-Table Database 目的 现在要创建一个最简单的表格(只能在内存中保存,只能添加数据,只能单表) 插入格式为insert 1 cstack foo@bar.com 表的格式为 id integer username varchar(32) email varchar(255) 这里可以使用sscanf()来检查输入参数 需要知识 关于unit32_t类型,可以查看这篇文章.其包含在stdint.h头文件之中 复习一下宏定义 #define size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)-\u003eAttribute) 这相当于定义了一个函数(动态类型). ROW_SIZE这个常量需要使用这个函数来计算出来(不同操作系统之间不一样). memcpy()函数:C和C++使用的内存拷贝函数，函数原型为void *memcpy(void *destin, void *source, unsigned n),函数的功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中，即从源source中拷贝n个字节到目标destin中. 实现 步骤:从底层开始实现 先是对Row进行定义,Row的序列化,再定义Table,然后就是寻找Row在Table 的位置. 这里定义了Row的结构体: #define COLUMN_USERNAME_SIZE 32 #define COLUMN_EMAIL_SIZE 255 typedef struct { uint32_t id; char username[COLUMN_USERNAME_SIZE]; char email[COLUMN_EMAIL_SIZE]; } Row; 序列化存储Row(将row放在一个连续的地址中) column size(bytes) offset(起始地址) id 4 0 username 32 4 email 255 36 total 291 利用地址来copy内容 void serialize_row(Row* source , void* destination) //序列化 { memcpy(destination + ID_OFFSET, \u0026(source-\u003eid), ID_SIZE); memcpy(destination + USERNAME_OFFSET, \u0026(source-\u003eusername), USERNAME_SIZE); memcpy(destination + EMAIL_OFFSET, \u0026(source-\u003eemail), EMAIL_SIZE); } void deserialize_row(void* source, Row* destination) { //反序列化 memcpy(\u0026(destination-\u003eid), source + ID_OFFSET, ID_SIZE); memcpy(\u0026(destination-\u003eusername), source + USERNAME_OFFSET, USERNAME_SIZE); memcpy(\u0026(destination-\u003eemail), source + EMAIL_OFFSET, EMAIL_SIZE); } 这里是Table的结构定义 const uint32_t PAGE_SIZE = 4096; #define TABLE_MAX_PAGES 100 const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE; const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES; typedef struct { uint32_t num_rows; void* pages[TABLE_MAX_PAGES]; //用一个大的数组来模拟内存 } Table; 接下来找到某一行写入内存的位置(内存-\u003e页面-\u003e行): void* row_slot(Table* table, uint32_t row_num) { uint32_t page_num = row_num / ROWS_PER_PAGE; //页面的序号 void* page = table-\u003epages[page_num]; //切换到当前page if (page == NULL) { // 页面为空时申请内存 page = table-\u003epages[page_num] = malloc(PAGE_SIZE); } uint32_t row_offset = row_num % ROWS_PER_PAGE; //计算行在页的位置 uint32_t byte_offset = row_offset * ROW_SIZE; //计算以字节计算的行的起始位置 return page + byte_offset; //返回写入地址 } 到这里为止,select,insert方法的底层都已经实现完了. ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:5","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"Part4 一些修正与测试 atoi()函数将字符串化为整数 sscanf()函数的缺点在于若输入字符串大于buffer,则会造成溢出. 应该为strtok函数: char * strtok ( char * str, const char * delimiters ); 修正一下: +PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) { + statement-\u003etype = STATEMENT_INSERT; + + char* keyword = strtok(input_buffer-\u003ebuffer, \" \"); + char* id_string = strtok(NULL, \" \"); + char* username = strtok(NULL, \" \"); + char* email = strtok(NULL, \" \"); + + if (id_string == NULL || username == NULL || email == NULL) { + return PREPARE_SYNTAX_ERROR; + } + + int id = atoi(id_string); + if (strlen(username) \u003e COLUMN_USERNAME_SIZE) { + return PREPARE_STRING_TOO_LONG; + } + if (strlen(email) \u003e COLUMN_EMAIL_SIZE) { + return PREPARE_STRING_TOO_LONG; + } + + statement-\u003erow_to_insert.id = id; + strcpy(statement-\u003erow_to_insert.username, username); + strcpy(statement-\u003erow_to_insert.email, email); + + return PREPARE_SUCCESS; +} + PrepareResult prepare_statement(InputBuffer* input_buffer, Statement* statement) { if (strncmp(input_buffer-\u003ebuffer, \"insert\", 6) == 0) { + return prepare_insert(input_buffer, statement); - statement-\u003etype = STATEMENT_INSERT; - int args_assigned = sscanf( - input_buffer-\u003ebuffer, \"insert %d %s %s\", \u0026(statement-\u003erow_to_insert.id), - statement-\u003erow_to_insert.username, statement-\u003erow_to_insert.email); - if (args_assigned \u003c 3) { - return PREPARE_SYNTAX_ERROR; - } - return PREPARE_SUCCESS; } 还有ID可能为负数的错误. 由于 没安装教程的测试语言,尝试使用shell语言来测试. stdin：输入流 stdout：输出流 strerr：错误流 #include \u003cstdio.h\u003e int main() { //printf(\"please input the value a : \\n\"); fprintf(stdout, \"please input the value a :\"); int a ; //scanf(\"%d\", \u0026a); fscanf的封装 fscanf(stdin, \"%d\", \u0026a); if(a\u003c0) { fprintf(stderr, \"the value must \u003e 0 \\n\"); return 1; } return 0; } C的输入输出流 ./main.out \u003e a.txt //覆盖 ./main.out \u003e\u003e a.txt //追加 ./main.out \u003c input.txt //将input中的内容当做输入流 #1\u003e输出流 2\u003e错误流 \u003c输入流 ./main.out 1\u003estdout.txt 2\u003estderr.txt \u003cinput.txt ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:6","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"Part 5 保存数据到硬盘 可以 将Page直接直接拷贝到Database文件中,再定义一个Pager类来通过索引访问相应的page块. typedef struct{ int file_descriptor; uint32_t file_length; void* pages[TABLE_MAX_PAGES]; }Pager; open()函数. ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); lseek():移动文件读写光标 欲将读写位置移到文件开头时:lseek(int fildes, 0, SEEK_SET); 欲将读写位置移到文件尾时:lseek(int fildes, 0, SEEK_END); 想要取得目前文件位置时:lseek(int fildes, 0, SEEK_CUR); ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:7","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"Part 6 The Cursor Abstraction 光标的抽象主要是为了达到以下的目的: 创建一个在表开头的光标 创建一个在表末尾的光标 访问当前光标指向的行 移动光标到下一行去 删除当前指向的行 编辑当前指向的行 搜索ID,且定位到相应的行 光标的结构定义为: typedef struct { Table* table; uint32_t row_num; bool end_of_table; // Indicates a position one past the last element } Cursor; 一切对于虚拟机的操作都可以转化为对光标的抽象操作了 ","date":"2020-08-11","objectID":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/:0:8","tags":["SQL","Project","CS"],"title":"跟随教程从头写自己的数据库(零基础入手)","uri":"/%E8%B7%9F%E9%9A%8Fdb_tutorial%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"proc是一个系统文件目录,存放着记录当前运行状态的文件. ","date":"2020-04-19","objectID":"/proc%E5%88%9D%E6%8E%A2/:0:0","tags":["Linux","OS"],"title":"proc 初探","uri":"/proc%E5%88%9D%E6%8E%A2/"},{"categories":null,"content":"proc 初探（Deepin下） acpi 目录 高级配置和电源接口 支持OS设置和控制各个硬件部件 wakeup 文件 asound 文件夹 声音设备相关 buddyinfo 内存管理算法的状态 bus 文件夹 总线管理 input 文件夹 devices 输入设备列表 handlers 解决方案 pci 文件夹 devices pci连接设备 cgroups 将进程进行分组，对一组进程进行统一资源监控和限制 cmdline 启动当前进程的完整命令 or 启动时传递给kernel的参数信息 consoles 可以查看系统运行的所有终端 cpuinfo 目前CPU信息 crypto 内核使用的所有已安装的加密密码及细节 devices 已经加载的设备 diskstats 硬盘状态 dma 已注册使用的ISA DMA频道列表（不明白） driver 驱动 rtc RTC驱动 execdomains 可能是内核执行空间 fb 帧缓冲设备列表文件，包含帧缓冲设备的设备号和相关驱动信息 filesystems 当前被内核支持的文件系统类型列表 fs 挂载的文件系统类型及挂载的分区 interrupts 查看中断情况 iomem io设备内存缓冲区 ioports io端口资源分布 irq 各个中断具体情况 kallsyms linux内核符号表 内核中使用到的函数和变量地址 kcore 内存的映射 类比为内存中的alias keys 密钥 key-users 用户密钥 kmsg 似乎是内核的环形缓冲区 kpagecgroup kpagecount 包含一个64位值，该值表示每个page被映射的次数，通过PFN索引。 kpageflags 这个文件包含每一个page的64位的标记集，通过PFN索引 loadavg 平均负载也就是可运行的进程的平均数 locks 保存当前由内核锁定的文件的相关信息 mdstat 内核是否已经加载MD驱动 (利用条带化(stripping)技术将数据块均匀分布到多个磁盘上来提高虚拟设备的读写性能) meminfo 内存信息 misc 查看系统中装载的所有misc类设备 modules 列出了所有load进入内核的模块列表 mounts 文件挂载信息 mtrr 将内存类型与系统内存中的物理地址范围关联起来 net 网络信息与配置 pagetypeinfo buddyinfo文件的细分 partitions 查看分区信息 sched_debug 打印出所有cpu的信息 schedstat CPU调度时间统计 scsi 查看目前的磁盘信息 slabinfo gives information about memory usage on the slab level softirqs 查看软中断 stat 记录的是系统进程整体的统计信息 swaps 交换区信息 sys 包括所有的内核参数信息 sysrq-trigger （Magic System Request Key） 可以调用系统一些行为 sysvipc 包括进程间通信的信号量（sem）、共享内存（shm）、消息队列（msg）信息 thread-self 这是一个link，当访问次链接时，就会访问进程的/proc/self/task/tid目录 timer_list 打印per_cpu的hrtimer_bases信息以及基于此的timer列表 tty 查询当前系统tty的情况 uptime 启动时间 version 系统版本 vfs_changes 内核模块创建的接口文件，用来给上层用户态应用程序访问 vmallocinfo 由于系统的连续物理内存有限，这使得非连续物理内存的使用在linux内核中出现，查看非连续内存使用信息。 vmstat 取得虚拟内存统计信息 zoneinfo Zone的管理调度（虚拟内存相关） ","date":"2020-04-19","objectID":"/proc%E5%88%9D%E6%8E%A2/:1:0","tags":["Linux","OS"],"title":"proc 初探","uri":"/proc%E5%88%9D%E6%8E%A2/"},{"categories":null,"content":"以前写一个WPF的游戏时曾经用过Inoke方法来实现UI的实时更新,但是听说WinForm有更加简单的App.DoEvents()方法来更新UI. 后来找到了在WPF中实现类似函数的方法. private static DispatcherOperationCallback exitFrameCallback = new DispatcherOperationCallback(ExitFrame); public static void DoEvents() { DispatcherFrame nestedFrame = new DispatcherFrame(); DispatcherOperation exitOperation = Dispatcher.CurrentDispatcher.BeginInvoke(DispatcherPriority.Background,exitFrameCallback, nestedFrame); Dispatcher.PushFrame(nestedFrame); if (exitOperation.Status !=DispatcherOperationStatus.Completed) { exitOperation.Abort(); } } private static Object ExitFrame(Object state) { DispatcherFrame frame = state as DispatcherFrame; frame.Continue = false; return null; } 这样在需要的地方运行DoEvent()即可以实现UI的刷新.性能赶不上使用Inoke()方法的多线程刷新UI,但这个方法胜在实现上较为简单,不需要TimerTick()函数. ","date":"2020-04-14","objectID":"/wpf%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%B7%E6%96%B0ui%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["WPF"],"title":"WPF 中一个简单刷新 UI 的方法","uri":"/wpf%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%B7%E6%96%B0ui%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"在多个进程同时对一共享变量访问修改时就会产生竞争条件,若不进行互斥和同步控制,程序运行结果就会出现偏差.为了解决这一问题 E.W.Dijkstra 在1965年提出了信号量. ","date":"2020-04-14","objectID":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/:0:0","tags":["OS"],"title":"IPC中的信号量探究","uri":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/"},{"categories":null,"content":"什么是信号量 信号量是一种特殊的变量,使用一个整形变量来累计唤醒次数.设立两种操作up() 和down()来控制信号量. void down(semaphore s)//此操作为原子操作 { s--; if(s\u003c0) sleep(s); //进程进入阻塞状态 } void up(semaphore s)//此操作为原子操作 { s++; if(s\u003c=0) wakeup(s);//从信号量s的进程中唤醒一个 } ","date":"2020-04-14","objectID":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/:0:1","tags":["OS"],"title":"IPC中的信号量探究","uri":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/"},{"categories":null,"content":"以生产者-消费者模型为例 例子包括了三个信号量:mutex 、empty 和full #define N 100 typedef int semaphore; semphore mutex = 1; semphore empty = N; semphore full = 0; void producer() { int item; while(TRUE){ item = produce_item(); down(\u0026empty); down(\u0026mutex); instert_item(item); up(\u0026mutex); up(\u0026full); } } void consumer() { int item; while(TRUE){ down(\u0026full); down(\u0026mutex); item = remove_item(); up(\u0026mutex); up(\u0026empty); } } mutex的作用（互斥信号量） mutex限定了临界区只有一个进程运行(当mutex=1,producer可以进入临界区;当mutex=0,consumer可以进入临界区). empty和full的作用(同步信号量) empty与full是对偶的关系.两个信号量都可以起到保存信号的作用.例如当在简单的sleep-wakeup模型中,producer在阻塞前一瞬间被抢占CPU,切换到consumer并试图唤醒producer,若此时consumer也进入阻塞,那当切换回producer,两者都将同时阻塞. 而在信号量模型下,以上事件会变成:producer在down(\u0026empty)函数执行前被抢占CPU,此时empty=0,consumer将开始执行,循环多次后empty=N,full=0,consumer进入阻塞,这时切回producer,down(\u0026empty)却不会使producer阻塞,反而在执行到up(\u0026full)的时候会唤醒consumer.这样一来信号量很好的解决了这个问题.信号量的原子操作起到了决定性作用. 总结作用 保证事件发生的顺序 缓冲区满时,producer停止运行 缓冲区空时,consumer停止运行 读者优先:若已经有读者进入,后续读者皆可以进入 写者优先:只要有写者等待,后续写者必须等待 合理顺序:读者在先来的写者之后 ","date":"2020-04-14","objectID":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/:0:2","tags":["OS"],"title":"IPC中的信号量探究","uri":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/"},{"categories":null,"content":"解决思路 互斥信号量 限制进程进入进入临界区 同步信号量 定义信号量:数值代表可用消息数 数值为负:有等待进程 数值为正:有可用消息 等待消息进程:down(s) 无消息则本进程进入等待 有消息则读入消息 发出消息进程:up(s) 无等待进程则发出消息 有等待进程则释放等待进程 解析 empty信号量 信息：缓冲区所拥有的空格 行为：生产者调用down()减empty，若empty\u003c0进入阻塞态，消费者调用up()增加empty，若empty\u003c=0尝试唤醒生产者。 full信号量 信息：缓冲区装填的格子 行为：消费者调用down()减full，若full\u003c0进入阻塞态，生产者调用up()增加full，若full\u003c=0尝试唤醒消费者。 ","date":"2020-04-14","objectID":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/:0:3","tags":["OS"],"title":"IPC中的信号量探究","uri":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/"},{"categories":null,"content":"写者优先的读者写者问题 当读者数量远大于写者时，写者可能会一直处于阻塞状态而不能的到CPU。 此时需要写者优先规则（虽然会减少一部分并行效率）。 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cpthread.h\u003e #include \u003csemaphore.h\u003e #define ProNum 3 //生产者数量 #define ConNum 30 //消费者数量 #define N 6 //缓冲区大小 #define TRUE 1 typedef int semaphore; sem_t mutex; sem_t can_read; //是否允许读者读取（实现写者优先） char buffer[N];//缓冲区 int pointer=0;//缓冲区指针 void* produce(void * tid) { char item; int t=0; while(TRUE){ if(t%2==0) item='A'+(t++)%10; else item='a'+(t++)%10; sleep(2); sem_wait(\u0026mutex); printf(\"Write %c\\n\",item); buffer[pointer]=item; pointer=(pointer+1)%N; sem_post(\u0026mutex); sem_post(\u0026can_read); //写者写完后up(\u0026can_read) } } void* consume(void* tid) { char item; while(TRUE){ printf(\"%d tid ask for read\\n\",tid); sem_wait(\u0026can_read); //读者读前确保有剩余的读者可读信号量 sem_wait(\u0026mutex); pointer=abs((pointer-1)%N); item=buffer[pointer]; buffer[pointer]=NULL; sem_post(\u0026mutex); printf(\"Read: %c\\n\",item); } } int main() { printf(\"started!\\n\"); sem_init(\u0026mutex,0,1); sem_init(\u0026can_read,0,0); pthread_t threads[ProNum+ConNum]; int status,i; for(i=0;i\u003cProNum;i++) { status=pthread_create(\u0026threads[i],NULL,produce,(void *)i); } for(i=ProNum;i\u003cProNum+ConNum;i++) { status=pthread_create(\u0026threads[i],NULL,consume,(void *)i); } pthread_exit(0); return 0; } 可以把sem_post()看成下放允许，而sem_wait()看成是等待允许。 ","date":"2020-04-14","objectID":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/:0:4","tags":["OS"],"title":"IPC中的信号量探究","uri":"/ipc%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A2%E7%A9%B6/"},{"categories":null,"content":"此为做操作系统课程作业时,对shell语言的一些记录. ","date":"2020-03-06","objectID":"/linuxshellnote/:0:0","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"常用命令 ls 列出文件 -F 区分文件类型 -a 显示隐藏文件 -R 显示文件夹子文件夹 -l 显示更多信息，按行排列 过滤器：通配符筛选文件 touch 创建文件 -a 改变修改时间 cp 复制文件 mv 移动文件（重命名） cp source destination -i 提醒是否覆盖 -R 复制并创建目录 ln 链接文件 符号链接 ln -s data_file s1_data_file 是两个独立的文件 硬链接 ln datafile linkfile 两个相同的文件 修改一个文件的时候，其硬链接和符号链接都会被修改 rm 删除文件 -i 提示是否要删除 -f force删除 -r 递归删除子文件 mkdir 创建目录 -p 同时创建多个目录和子目录 rmdir 删除目录 只删除空目录 tree 显示目录树 file 查看文件类型 cat 显示文本数据 -n 加上行号 -b 给有文字的加上行号 -T 不让制表符出现 more 显示长文本 less 更多功能的显示长文本工具 tail 查看文件尾部 head 查看文件头部 ps 查看进程 -A -e 显示所有进程 -a 显示除控制进程以外的和无终端进程外的所有进程 -d 显示除控制进程以外的所有进程 -L 显示进程中的线程 -f 完整输出 --forest 树状显示父子关系(linux) top 实时显示运行情况 检测资源使用 kill 结束进程 -s 指定信号 kill -s HUP 3940 killall 通过进程名结束进程 挂载存储媒体 mount 类型:vfat ntfs ios9660 mount -t vfat /dev/sdb1 /media/disk 卸载 umount df 查看挂载硬盘情况 du显示该目录下所有文件 -c 显示文件大小 -h 用易读格式输出 排序数据 sort XXfile -n 按照数值方式排序 -M 识别月份名排序 grep [option] pattern [file] 在文件中查询某字符或模式 -v 反向搜索 -c 计行数 -e 多个模式 压缩单个文件gzip gzip 压缩文件 gzcat 查看压缩文件内容 gunzip 解压文件 tar 归档压缩数据 -c 创建一个新的tar文件 -r 追加文件 -t 显示文件内容 -f 输出结果到什么目录或什么文件 -x 提取文件 -z 将输出重定向给gzip解压内容 下载了开源软件之后，你会经常看到文件名以.tgz结尾。这些是gzip压缩过的tar文件可以 用命令tar -zxvf filename.tgz来解压。 bash -c string 运行某个命令 -i 启动交互bash -l 登陆shell形式启动 -r 目录受限制的bash -s 从标准输入中获取命令 ","date":"2020-03-06","objectID":"/linuxshellnote/:1:0","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"进程命令 在一行中加分号依次运行一系列命令 pwd; ls; cd /etc; pwd 加上括号会使其成为进程列表,生成一个子shell来只执行命令 (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL) 后台模式 将命令在后面加上\u0026 进入后台模式运行 使用ps 或者 jobs来查看后台作业 也可以讲进程列表置入后台 协程 coproc sleep 10 给进程起名字 coproc MyJob { sleep 10; } (Linux) 可用于通信 内建命令与外部命令 可以使用type分辨 外部命令会占据大量资源 history 记录之前输入的命令 !! 上一条命令 ! num 某一条命令 alias 命令缩写输入工具 创建自己的命令 alias name=cmd 删除已有命名 unalias name ","date":"2020-03-06","objectID":"/linuxshellnote/:2:0","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"环境变量 ","date":"2020-03-06","objectID":"/linuxshellnote/:3:0","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"全局变量VS局部变量 全局环境变量对所有的Shell及子Shell都可见;而局部环境变量仅对创建其的Shell可见.在变量名前加$来调用变量的值. env或printenv查看全局变量,可用echo $HOME 查看某个变量的值 set可以显示为某个进程设定的所有环境变量,包括全局变量、局部变量和用户定义变量. ","date":"2020-03-06","objectID":"/linuxshellnote/:3:1","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"变量设置 设置用户变量 可以通过等号来对变量进行赋值 my_variable=hello echo $my_variable 尽量遵循系统定义的变量使用大写,用户变量使用小写的规则. 设置全局变量 通过export将用户变量导出到全局变量中(不需要加$) my_variable=hello export my_variable 此时my_variable将成为一个全局变量.修改子shell中的全局变量不会影响父shell中的值. 删除环境变量 使用unset删除变量 unset my_variable $规则:使用变量时要加$,操作变量时不需要用. 除自之外,Bash有一些自带的环境变量. 设置PATH环境变量 在shell输入一个外部命令时,shell会查找PATH环境变量中的命令和程序来执行. echo $PATH 添加目录进入环境变量 PATH = $PATH:/myfolder #添加/myfloder路径进入环境变量 PATH = $PATH:. #添加当前目录进入环境变量 这种修改只能保持到本次关机或者退出之前. 使得环境变量持久化 各个发行版下的shell有类似于/etc/bash.bashrc的配置文件,最常见的四种为 $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile 这些是Bash的启动脚本,在之中加入自己的环境变量即可以使得变量持久化 ","date":"2020-03-06","objectID":"/linuxshellnote/:3:2","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"数组变量 同样可以定义数组环境变量,例如 mytest=(one two three four five) echo $mytest #输出整个数组(或者是第一个) echo $mytest[*] #输出整个数组 echo $mytest[3] #输出第四个值 unset mytest[2] #删除第三个值 ","date":"2020-03-06","objectID":"/linuxshellnote/:3:3","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"Vim编辑器 ","date":"2020-03-06","objectID":"/linuxshellnote/:4:0","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"基础操作 普通模式下 光标的移动 h 左移动光标 j 下移动光标 k 上移动光标 l 右移动光标 翻页 PageDown 或 Ctrl+F 下翻一页 PageUp 或 Ctrl+B 上翻一页 G 移到缓冲区最后一行 num G 移动到缓冲区第num行 gg 移到缓冲区第一行 命令行模式 q 未修改且退出 q! 取消修改并退出 w filename 保存到其他文件中 wq 保存并退出 编辑数据 x 删除当前字符 dd 删除当前行 dw 删除当前单词 d$ 删除至行尾 J 删除行尾的换行符 u 撤销 a 追加数据 A 在行尾追加数据 r char 用char替换光标当前字符 R text 用text覆盖当前位置数据 直到按下ESC 复制粘贴 y 复制 p 粘贴 查找与替换 / text 查找某文本 /+Enter 或 n 查找下一个 :s/old/new/g 替换所有old :n,ms/old/new/g 替换n行到m行之间的所有old :%s/old/new/g 替换整个文件中的所有old :%s/old/new/gc 替换整个文件中的所有old，但在每次出现时提示。 ","date":"2020-03-06","objectID":"/linuxshellnote/:4:1","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"构建脚本 ","date":"2020-03-06","objectID":"/linuxshellnote/:5:0","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"基础 脚本权限 对脚本赋予文件属主执行文件的权限 chmod u+x test 将脚本路径加入环境变量可以直接调用脚本 显示消息 echo 输出字符串 echo -n 将字符串输出在同一行(仅限于Bash) Mac可以通过\\c实现 变量的使用 环境变量 在环境变量前加上$来使用环境变量,可以使用${variable}来严格规定变量名 用户变量 使用等号赋值,在变量、等号和值之间不能出现空格. var1=10 var2=20 var3=testing var4=\"strill more testing\" 命令替换 使用反引号字符``或者$()来获取命令输出 debug=`date` debug1=$(who) 命令替换获得日期并生成文件 #!/bin/bash # copy the /usr/bin directory listing to a log file today=$(date +%y%m%d) ls /usr/bin -al \u003e log.$today 警告 命令替换会创建一个子shell来运行对应的命令。子shell(subshell)是由运行该脚本的shell 所创建出来的一个独立的子shell(child shell)。正因如此，由该子shell所执行命令是无法 使用脚本中所创建的变量的。 在命令行提示符下使用路径./运行命令的话，也会创建出子shell;要是运行命令的时候 不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。 在命令行提示符下运行脚本时一定要留心! 重定向输入输出 输出重定向 \u003e完成将命令的输出发送到一个文件中,\u003e\u003e表示将内容追加到文件中 $ who \u003e test6 $ cat test6 user pts/0 Feb 10 17:55 输入重定向 输入重定向恰好相反 command \u003c inputfile $ wc \u003c test6 # wc : wordcount 2 11 60 $ 内联输入重定向 command \u003c\u003c marker 在命令行上使用内联输入重定向时，shell会用PS2环境变量中定义的次提示符(参见第6章) 来提示输入数据。下面是它的使用情况。 $ wc \u003c\u003c EOF \u003e test string 1 \u003e test string 2 \u003e test string 3 \u003e EOF 管道(Pipe) 有时需要将一个命令的输出作为另一个命令的输入。这可以用重定向来实现，只是有些笨拙。 $ rpm -qa \u003e rpm.list $ sort \u003c rpm.list abrt-1.1.14-1.fc14.i686 abrt-addon-ccpp-1.1.14-1.fc14.i686 abrt-addon-kerneloops-1.1.14-1.fc14.i686 abrt-addon-python-1.1.14-1.fc14.i686 abrt-desktop-1.1.14-1.fc14.i686 abrt-gui-1.1.14-1.fc14.i686 abrt-libs-1.1.14-1.fc14.i686 abrt-plugin-bugzilla-1.1.14-1.fc14.i686 abrt-plugin-logger-1.1.14-1.fc14.i686 abrt-plugin-runapp-1.1.14-1.fc14.i686 acl-2.2.49-8.fc14.i686 ... 管道连接可以解决这个问题,|将一个命令的输出重定向到另一个命令中. command1 | command2 Linux会同时运行两个命令,在系统内部连接起来,在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。 $ rpm -qa | sort | more 到目前为止，管道最流行的用法之一是将命令产生的大量输出通过管道传送给more命令。 这对ls命令来说尤为常见. 数学运算 expr命令 使用expr命令可以进行一些简单的数学运算 $expr 1 + 5 6 尽管标准操作符在expr命令中工作得很好，但在脚本或命令行上使用它们时仍有问题出现。 许多expr命令操作符在shell中另有含义(比如星号)。当它们出现在在expr命令中时，会得到一 些诡异的结果。 使用方括号 使用$[]处理数学表达式会更加方便 $ cat test8 #!/bin/bash var1=100 var2=45 var3=$[$var1 / $var2] echo The final result is $var3 $ chmod u+x test8 $ ./test8 The final result is 2 $ 但是bash仅支持整数运算,zshell(zsh)提供了完整的浮点数算术操作,或者也可以使用bc来进行浮点运算. 退出脚本 查看退出状态码 shell中运行的每个命令都使用退出状态码(exit status)告诉shell它已经运行完毕。退出状态 码是一个0~255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用。 Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。对于需要进行检查的 命令，必须在其运行完毕后立刻查看或使用$?变量。它的值会变成由shell所执行的最后一条命令的退出状态码。 $ date Sat Jan 15 10:01:30 EDT 2014 $ echo $? 0 $ exit 命令 使用exit可以自行返回状态码 exit 127 ","date":"2020-03-06","objectID":"/linuxshellnote/:5:1","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"},{"categories":null,"content":"结构化命令 if-then bash中最基本的结构化语句为 if command then commands fi 若if后的command返回状态码为0,则commands会运行,若返回状态码非0,则会跳过then中的内容. 同时,也有else语句,也有elif语句 if command then commands else commands fi if command1 then commands elif command2 then more commands fi test 命令 检查变量是否有内容 在if语句中看到的都是普通shell命令。你可能想问，if-then语句是否能测试 命令退出状态码之外的条件。 答案是不能。但在bash shell中有个好用的工具可以帮你通过if-then语句测试其他条件。 test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立， test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句 以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得 if-then语句不会再被执行。 test命令的格式非常简单。 test condition condition是test命令要测试的一系列参数和值。当用在if-then语句中时，test命令看 起来是这样的。 if test condition then commands fi 用test可以确定变量中是否有内容 也可以用[]替代test. 数值比较 value1=10 value2=2 if [ $value1 -lt $value2 ] then echo \" $value1 \u003c $value2 \" else echo \" $value1 \u003e= $value2 \" fi 字符串比较 通常需要添加转义字符 if [ $value1 \\\u003c $value2 ] then echo \" $value1 \u003c $value2 \" else echo \" $value1 \u003e= $value2 \" fi 在比较测试中，大写字母被认为是小于小写字母的。但sort命令恰好相反。当你将同样的 字符串放进文件中并用sort命令排序时，小写字母会先出现。这是由各个命令使用的排序技术 不同造成的。 文件比较 文件比较是最常用,功能最强大的比较形式. 复合条件 可以用布尔逻辑\u0026\u0026 ||来组合条件 $ cat test22.sh #!/bin/bash # testing compound comparisons # if [ -d $HOME ] \u0026\u0026 [ -w $HOME/testing ] then echo \"The file exists and you can write to it\" else echo \"I cannot write to the file\" fi $ $ ./test22.sh I cannot write to the file $ $ touch $HOME/testing $ $ ./test22.sh The file exists and you can write to it $ If-then 高级特性 (()) 双括号命令允许在比较过程中使用高级数学表达式. $ cat test23.sh #!/bin/bash # using double parenthesis # val1=10 # if (( $val1 ** 2 \u003e 90 )) then (( val2 = $val1 ** 2 )) echo \"The square of $val1 is $val2\" fi $ $ ./test23.sh The square of 10 is 100 [[]] 双方括号允许在比较过程中使用字符串的高级特性.可以利用正则表达式来匹配模式. $ cat test24.sh #!/bin/bash # using pattern matching if [[ $USER =~ r* ]] then echo \"Hello $USER\" else echo \"Sorry, I do not know you\" fi $ ./test24.sh Hello rich $ case 命令 case命令在bash中格式为 case variable in pattern1 | pattern2) commands1;; pattern3) commands2;; *) default commands;; esac 也类似于其他语言中的case $ cat test26.sh #!/bin/bash # using the case command # case $USER in rich | barbara) echo \"Welcome, $USER\" echo \"Please enjoy your visit\";; testing) echo \"Special testing account\";; jessica) echo \"Do not forget to log off when you're done\";; *) echo \"Sorry, you are not allowed here\";; esac $ $ ./test26.sh Welcome, rich Please enjoy your visit $ ","date":"2020-03-06","objectID":"/linuxshellnote/:5:2","tags":["Linux","OS"],"title":"Linux Shell 笔记","uri":"/linuxshellnote/"}]